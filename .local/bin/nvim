#!/usr/bin/env lua

local ffi = require("ffi")
local unistd = require("posix.unistd")
local fcntl = require("posix.fcntl")
local signal = require("posix.signal")
local wait = require("posix.sys.wait")
local stat = require("posix.sys.stat")
local stdlib = require("posix.stdlib")

ffi.cdef([[
  typedef int pid_t;
  pid_t setsid(void);

  struct flock {
    long long l_start;
    long long l_len;
    pid_t l_pid;
    short l_type;
    short l_whence;
  };

  int fcntl(int fd, int cmd, ...);
]])

local HOME = os.getenv("HOME")
local NVIM_BIN = HOME .. "/.local/share/shimlink/bin/nvim"
local DEFAULT_SOCK = HOME .. "/.config/nvim/nvim.sock"

local function derive_paths(sock)
  local sock_dir = sock:match("(.+)/[^/]+$")
  local sock_name = sock:match("([^/]+)$"):gsub("%.sock$", "")

  return {
    sock = sock,
    pid = sock_dir .. "/" .. sock_name .. ".pid",
    log = sock_dir .. "/" .. sock_name .. ".log"
  }
end

local function parse_socket_option(args)
  local socket_path = nil
  local new_args = {}
  local i = 1

  while i <= #args do
    if args[i] == "--socket" and i < #args then
      socket_path = args[i + 1]
      i = i + 2
    else
      table.insert(new_args, args[i])
      i = i + 1
    end
  end

  return socket_path, new_args
end

local function expand_tilde(path)
  if path:sub(1, 2) == "~/" then
    return HOME .. path:sub(2)
  elseif path == "~" then
    return HOME
  end
  return path
end

local function get_socket_path(cli_socket)
  if cli_socket then
    return expand_tilde(cli_socket)
  end

  local env_socket = os.getenv("NVIM_SOCKET")
  if env_socket then
    return expand_tilde(env_socket)
  end

  return DEFAULT_SOCK
end

local function mkdir_p(path)
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end

  local current = path:sub(1, 1) == "/" and "/" or ""
  for _, part in ipairs(parts) do
    current = current .. part .. "/"
    local ok, err = pcall(stat.mkdir, current, tonumber("755", 8))
    if not ok and not err:match("File exists") then
      return nil, "failed to create directory " .. current .. ": " .. tostring(err)
    end
  end
  return true
end

local function file_exists(path)
  local ok, s = pcall(stat.stat, path)
  return ok and s ~= nil
end

local function read_file(path)
  local f = io.open(path, "r")
  if not f then
    return nil
  end
  local content = f:read("*all")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "w")
  if not f then
    return nil, "failed to write file: " .. path
  end
  f:write(content)
  f:close()
  return true
end

local function is_process_running(pid)
  return signal.kill(pid, 0) == 0
end

local function get_running_pid(pidfile)
  local pid_str = read_file(pidfile)
  if not pid_str then
    return nil
  end
  local pid = tonumber(pid_str)
  if pid and is_process_running(pid) then
    return pid
  end
  return nil
end

local function wait_for_socket(socket_path, timeout)
  timeout = timeout or 5
  local sleep_interval_ms = 100  -- 100ms
  local time = require("posix.time")
  local elapsed = 0

  while elapsed < timeout do
    if file_exists(socket_path) then
      local socket = require("posix.sys.socket")
      local sock_fd = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
      if sock_fd and sock_fd >= 0 then
        local sockaddr = {
          family = socket.AF_UNIX,
          path = socket_path
        }
        local ok = socket.connect(sock_fd, sockaddr)
        unistd.close(sock_fd)
        if ok == 0 then
          return true
        end
      end
    end

    -- nanosleep takes seconds and nanoseconds
    time.nanosleep({tv_sec = 0, tv_nsec = sleep_interval_ms * 1000000})
    elapsed = elapsed + (sleep_interval_ms / 1000)
  end

  return false
end

local function acquire_pidfile_lock(pidfile)
  local lockfd = fcntl.open(pidfile, fcntl.O_RDWR + fcntl.O_CREAT, tonumber("644", 8))
  if not lockfd or lockfd < 0 then
    return nil, "failed to open pidfile for locking"
  end

  local lock = ffi.new("struct flock")
  lock.l_start = 0
  lock.l_len = 0
  lock.l_pid = 0
  lock.l_type = fcntl.F_WRLCK
  lock.l_whence = unistd.SEEK_SET

  local ret = ffi.C.fcntl(lockfd, fcntl.F_SETLK, lock)
  if ret == -1 then
    local errno = ffi.errno()
    unistd.close(lockfd)
    return nil, string.format("another instance is starting (errno: %d)", errno)
  end

  return lockfd
end

local function release_pidfile_lock(lockfd)
  if lockfd then
    unistd.close(lockfd)
  end
end

local function load_zsh_environment()
  local posix = require("posix")
  local handle = posix.popen({"zsh", "-i", "-l", "-c", "env -0"}, "r")
  if not handle then
    return
  end

  local output = unistd.read(handle.fd, 65536) or ""
  wait.wait(handle.pids[1])
  unistd.close(handle.fd)

  local i = 1
  while i <= #output do
    local next_null = output:find("\0", i, true)
    if not next_null then
      break
    end
    local line = output:sub(i, next_null - 1)
    local key, value = line:match("^([^=]+)=(.*)$")
    if key then
      stdlib.setenv(key, value)
    end
    i = next_null + 1
  end
end

local function setup_nvim_environment()
  load_zsh_environment()
  stdlib.setenv("NVIM_SERVER_MODE", "1")
end

local function exec_nvim_server(sock)
  os.remove(sock)
  unistd.execp(NVIM_BIN, {"--listen", sock, "--headless"})
end

local function cmd_start(paths)
  local ok, err = mkdir_p(paths.pid:match("(.+)/[^/]+$"))
  if not ok then
    io.stderr:write("error: " .. err .. "\n")
    return 1
  end
  ok, err = mkdir_p(paths.log:match("(.+)/[^/]+$"))
  if not ok then
    io.stderr:write("error: " .. err .. "\n")
    return 1
  end

  local lockfd
  lockfd, err = acquire_pidfile_lock(paths.pid)
  if not lockfd then
    io.stderr:write("failed to acquire lock: " .. err .. "\n")
    return 1
  end

  local pid = get_running_pid(paths.pid)
  if pid then
    release_pidfile_lock(lockfd)
    io.write("nvim server already running\n")
    return 0
  end

  os.remove(paths.sock)

  local child_pid = unistd.fork()
  if child_pid == 0 then
    ffi.C.setsid()

    local grandchild_pid = unistd.fork()
    if grandchild_pid == 0 then
      local logfd = fcntl.open(paths.log, fcntl.O_WRONLY + fcntl.O_CREAT + fcntl.O_APPEND, tonumber("644", 8))
      if logfd then
        unistd.dup2(logfd, unistd.STDOUT_FILENO)
        unistd.dup2(logfd, unistd.STDERR_FILENO)
        unistd.close(logfd)
      end

      local devnull = fcntl.open("/dev/null", fcntl.O_RDONLY)
      if devnull then
        unistd.dup2(devnull, unistd.STDIN_FILENO)
        unistd.close(devnull)
      end

      for fd = 3, 255 do
        pcall(unistd.close, fd)
      end

      unistd.chdir(HOME)
      setup_nvim_environment()
      exec_nvim_server(paths.sock)
      os.exit(1)
    else
      local ok, err = write_file(paths.pid, tostring(grandchild_pid))
      if not ok then
        io.stderr:write("error: " .. err .. "\n")
        release_pidfile_lock(lockfd)
        os.exit(1)
      end
      release_pidfile_lock(lockfd)
      os.exit(0)
    end
  else
    wait.wait(child_pid)

    if wait_for_socket(paths.sock, 5) then
      pid = get_running_pid(paths.pid)
      if pid then
        io.write("manual: nvim server started\n")
        return 0
      else
        io.stderr:write("manual: nvim server process died after starting, check " .. paths.log .. "\n")
        os.remove(paths.pid)
        return 1
      end
    else
      io.stderr:write("manual: nvim server failed to start: socket not ready after 5 seconds, check " .. paths.log .. "\n")
      pid = get_running_pid(paths.pid)
      if pid then
        signal.kill(pid, signal.SIGTERM)
      end
      os.remove(paths.pid)
      return 1
    end
  end
end

local function cmd_stop(paths)
  local pid = get_running_pid(paths.pid)
  if pid then
    signal.kill(pid, signal.SIGTERM)
    os.remove(paths.pid)
    io.write("manual: nvim server stopped\n")
  else
    io.write("manual: nvim server not running\n")
  end
  os.remove(paths.sock)
  return 0
end

local function cmd_status(paths)
  local pid = get_running_pid(paths.pid)
  if pid then
    io.write(string.format("nvim server is running (pid %d) at %s\n", pid, paths.sock))
    return 0
  else
    io.write(string.format("nvim server is not running at %s\n", paths.sock))
    return 1
  end
end

local function run_command(args)
  local posix = require("posix")
  local handle = posix.popen(args, "r")
  if not handle then
    return 1
  end
  local _, reason, status = wait.wait(handle.pids[1])
  unistd.close(handle.fd)
  if reason == "exited" then
    return status
  end
  return 1
end

local function cmd_restart(paths)
  cmd_stop(paths)
  unistd.sleep(1)
  return cmd_start(paths)
end

local function cmd_cleanup(paths)
  os.remove(paths.sock)
  return 0
end

local commands = {
  start = cmd_start,
  stop = cmd_stop,
  status = cmd_status,
  restart = cmd_restart,
  cleanup = cmd_cleanup,
}

local function daemon_mode(args)
  local cli_socket, remaining_args = parse_socket_option(args)
  local socket_path = get_socket_path(cli_socket)
  local paths = derive_paths(socket_path)

  local command = remaining_args[1] or ""
  local cmd_fn = commands[command]

  if cmd_fn then
    return cmd_fn(paths)
  else
    io.stderr:write("nvimd: unknown command: " .. command .. "\n")
    io.stderr:write("Usage: nvimd [--socket PATH] {start|stop|status|restart|cleanup}\n")
    return 1
  end
end

local function has_server_flag(args)
  for _, arg in ipairs(args) do
    if arg == "--server" then
      return true
    end
  end
  return false
end

local function is_socket_connectable(socket_path)
  if not file_exists(socket_path) then
    return false
  end

  local socket = require("posix.sys.socket")
  local sock_fd = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
  if not sock_fd or sock_fd < 0 then
    return false
  end

  local sockaddr = {
    family = socket.AF_UNIX,
    path = socket_path
  }
  local ok = socket.connect(sock_fd, sockaddr)
  unistd.close(sock_fd)
  return ok == 0
end

local function client_mode(args)
  local nvim_invim = os.getenv("NVIM_INVIM")
  local nvim_server_mode = os.getenv("NVIM_SERVER_MODE")

  if not nvim_invim and not nvim_server_mode then
    local cli_socket, remaining_args = parse_socket_option(args)
    local socket_path = get_socket_path(cli_socket)
    local paths = derive_paths(socket_path)
    local has_server = has_server_flag(remaining_args)

    if not is_socket_connectable(paths.sock) then
      cmd_start(paths)
    end

    local new_args = {}
    if not has_server then
      table.insert(new_args, "--server")
      table.insert(new_args, paths.sock)
    end
    for _, arg in ipairs(remaining_args) do
      table.insert(new_args, arg)
    end
    unistd.execp(NVIM_BIN, new_args)
  else
    local new_args = {}
    for _, arg in ipairs(args) do
      table.insert(new_args, arg)
    end
    unistd.execp(NVIM_BIN, new_args)
  end
end

local function cleanup_and_exit(signum, paths)
  os.remove(paths.sock)
  if file_exists(paths.pid) then
    local pid = get_running_pid(paths.pid)
    if not pid then
      os.remove(paths.pid)
    end
  end
  os.exit(128 + signum)
end

local function main(args)
  local program_name = args[0]:match("([^/]+)$")

  local cmd_args = {}
  for i = 1, #args do
    cmd_args[i] = args[i]
  end

  local cli_socket, _ = parse_socket_option(cmd_args)
  local socket_path = get_socket_path(cli_socket)
  local paths = derive_paths(socket_path)

  signal.signal(signal.SIGINT, function() cleanup_and_exit(signal.SIGINT, paths) end)
  signal.signal(signal.SIGTERM, function() cleanup_and_exit(signal.SIGTERM, paths) end)

  if program_name == "nvimd" or program_name == "nvimd.lua" then
    return daemon_mode(cmd_args)
  else
    return client_mode(cmd_args)
  end
end

local args = {[0] = arg[0]}
for i = 1, #arg do
  args[i] = arg[i]
end

local ok, result = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(result) .. "\n")
  os.exit(1)
end

os.exit(result or 0)
