#!/usr/bin/env luajit

local ffi = require("ffi")
local unistd = require("posix.unistd")
local fcntl = require("posix.fcntl")
local signal = require("posix.signal")
local wait = require("posix.sys.wait")
local stat = require("posix.sys.stat")
local stdlib = require("posix.stdlib")

ffi.cdef([[
  typedef int pid_t;
  pid_t setsid(void);
]])

local HOME = os.getenv("HOME")
local NVIM_BIN = HOME .. "/.local/share/shimlink/bin/nvim"
local SOCK = HOME .. "/.config/nvim/nvim.sock"
local PIDFILE = HOME .. "/.local/state/nvim/nvim.pid"
local LOGFILE = HOME .. "/.local/state/nvim/nvim.log"

local function mkdir_p(path)
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end

  local current = path:sub(1, 1) == "/" and "/" or ""
  for _, part in ipairs(parts) do
    current = current .. part .. "/"
    stat.mkdir(current, tonumber("755", 8))
  end
end

local function file_exists(path)
  local s = stat.stat(path)
  return s ~= nil
end

local function read_file(path)
  local f = io.open(path, "r")
  if not f then
    return nil
  end
  local content = f:read("*all")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "w")
  if not f then
    return nil, "failed to write file: " .. path
  end
  f:write(content)
  f:close()
  return true
end

local function is_process_running(pid)
  return signal.kill(pid, 0) == 0
end

local function get_running_pid()
  local pid_str = read_file(PIDFILE)
  if not pid_str then
    return nil
  end
  local pid = tonumber(pid_str)
  if pid and is_process_running(pid) then
    return pid
  end
  return nil
end

local function load_zsh_environment()
  local posix = require("posix")
  local handle = posix.popen({"zsh", "-i", "-l", "-c", "env -0"}, "r")
  if not handle then
    return
  end

  local output = unistd.read(handle.fd, 65536) or ""
  wait.wait(handle.pids[1])
  unistd.close(handle.fd)

  local i = 1
  while i <= #output do
    local next_null = output:find("\0", i, true)
    if not next_null then
      break
    end
    local line = output:sub(i, next_null - 1)
    local key, value = line:match("^([^=]+)=(.*)$")
    if key then
      stdlib.setenv(key, value)
    end
    i = next_null + 1
  end
end

local function setup_nvim_environment()
  load_zsh_environment()
  stdlib.setenv("NVIM_SERVER_MODE", "1")
end

local function exec_nvim_server()
  os.remove(SOCK)
  unistd.execp(NVIM_BIN, {NVIM_BIN, "--listen", SOCK, "--headless"})
end

local function cmd_serve()
  setup_nvim_environment()
  exec_nvim_server()
end

local function cmd_start()
  local pid = get_running_pid()
  if pid then
    io.write("nvim server already running\n")
    return 0
  end

  mkdir_p(PIDFILE:match("(.+)/[^/]+$"))
  mkdir_p(LOGFILE:match("(.+)/[^/]+$"))
  os.remove(SOCK)

  local child_pid = unistd.fork()
  if child_pid == 0 then
    ffi.C.setsid()

    local grandchild_pid = unistd.fork()
    if grandchild_pid == 0 then
      local logfd = fcntl.open(LOGFILE, fcntl.O_WRONLY + fcntl.O_CREAT + fcntl.O_APPEND, tonumber("644", 8))
      if logfd then
        unistd.dup2(logfd, unistd.STDOUT_FILENO)
        unistd.dup2(logfd, unistd.STDERR_FILENO)
        unistd.close(logfd)
      end

      local devnull = fcntl.open("/dev/null", fcntl.O_RDONLY)
      if devnull then
        unistd.dup2(devnull, unistd.STDIN_FILENO)
        unistd.close(devnull)
      end

      for fd = 3, 255 do
        unistd.close(fd)
      end

      unistd.chdir(HOME)
      setup_nvim_environment()
      exec_nvim_server()
      os.exit(1)
    else
      write_file(PIDFILE, tostring(grandchild_pid))
      os.exit(0)
    end
  else
    wait.wait(child_pid)
    unistd.sleep(1)

    pid = get_running_pid()
    if pid then
      io.write("nvim server started\n")
      return 0
    else
      io.stderr:write("nvim server failed to start, check " .. LOGFILE .. "\n")
      os.remove(PIDFILE)
      return 1
    end
  end
end

local function cmd_stop()
  local pid = get_running_pid()
  if pid then
    signal.kill(pid, signal.SIGTERM)
    os.remove(PIDFILE)
    io.write("nvim server stopped\n")
  else
    io.write("nvim server not running\n")
  end
  os.remove(SOCK)
  return 0
end

local function cmd_status()
  local pid = get_running_pid()
  if pid then
    io.write(string.format("nvim server is running (pid %d)\n", pid))
    return 0
  else
    io.write("nvim server is not running\n")
    return 1
  end
end

local function is_systemd_running()
  return file_exists("/run/systemd/system")
end

local function run_command(args)
  local posix = require("posix")
  local handle = posix.popen(args, "r")
  if handle then
    wait.wait(handle.pids[1])
    unistd.close(handle.fd)
  end
end

local function cmd_reload()
  if jit.os == "OSX" then
    local uid = unistd.getuid()
    run_command({"launchctl", "bootout", "gui/" .. uid .. "/com.user.nvim"})
    unistd.sleep(0.5)
    run_command({"launchctl", "bootstrap", "gui/" .. uid, HOME .. "/Library/LaunchAgents/com.user.nvim.plist"})
    run_command({"launchctl", "enable", "gui/" .. uid .. "/com.user.nvim"})
    run_command({"launchctl", "kickstart", "gui/" .. uid .. "/com.user.nvim"})
  else
    if is_systemd_running() then
      run_command({"systemctl", "--user", "daemon-reload"})
    end
  end
  return 0
end

local function cmd_restart()
  if jit.os == "OSX" then
    local uid = unistd.getuid()
    run_command({"launchctl", "kickstart", "-k", "gui/" .. uid .. "/com.user.nvim"})
  else
    if is_systemd_running() then
      run_command({"systemctl", "--user", "restart", "nvim"})
    else
      cmd_stop()
      unistd.sleep(1)
      return cmd_start()
    end
  end
  return 0
end

local function cmd_cleanup()
  os.remove(SOCK)
  return 0
end

local commands = {
  serve = cmd_serve,
  start = cmd_start,
  stop = cmd_stop,
  status = cmd_status,
  reload = cmd_reload,
  restart = cmd_restart,
  cleanup = cmd_cleanup,
}

local function daemon_mode(args)
  local command = args[1] or ""
  local cmd_fn = commands[command]

  if cmd_fn then
    return cmd_fn()
  else
    io.stderr:write("nvimd: unknown command: " .. command .. "\n")
    io.stderr:write("Usage: nvimd {serve|start|stop|status|restart|reload|cleanup}\n")
    return 1
  end
end

local function client_mode(args)
  local nvim_invim = os.getenv("NVIM_INVIM")
  local nvim_server_mode = os.getenv("NVIM_SERVER_MODE")

  if not nvim_invim and not nvim_server_mode then
    local new_args = {NVIM_BIN, "--server", SOCK}
    for _, arg in ipairs(args) do
      table.insert(new_args, arg)
    end
    unistd.execp(NVIM_BIN, new_args)
  else
    local new_args = {NVIM_BIN}
    for _, arg in ipairs(args) do
      table.insert(new_args, arg)
    end
    unistd.execp(NVIM_BIN, new_args)
  end
end

local function main(args)
  local program_name = args[0]:match("([^/]+)$")

  if program_name == "nvimd" or program_name == "nvimd.lua" then
    local cmd_args = {}
    for i = 1, #args do
      cmd_args[i] = args[i]
    end
    return daemon_mode(cmd_args)
  else
    local cmd_args = {}
    for i = 1, #args do
      cmd_args[i] = args[i]
    end
    return client_mode(cmd_args)
  end
end

local args = {[0] = arg[0]}
for i = 1, #arg do
  args[i] = arg[i]
end

local ok, result = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(result) .. "\n")
  os.exit(1)
end

os.exit(result or 0)
