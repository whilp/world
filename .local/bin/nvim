#!/usr/bin/env luajit

local ffi = require("ffi")
local unistd = require("posix.unistd")
local fcntl = require("posix.fcntl")
local signal = require("posix.signal")
local wait = require("posix.sys.wait")
local stat = require("posix.sys.stat")
local stdlib = require("posix.stdlib")

ffi.cdef([[
  typedef int pid_t;
  pid_t setsid(void);

  struct flock {
    long long l_start;
    long long l_len;
    pid_t l_pid;
    short l_type;
    short l_whence;
  };

  int fcntl(int fd, int cmd, ...);
]])

local HOME = os.getenv("HOME")
local NVIM_BIN = HOME .. "/.local/share/shimlink/bin/nvim"
local SOCK = HOME .. "/.config/nvim/nvim.sock"
local PIDFILE = HOME .. "/.local/state/nvim/nvim.pid"
local LOGFILE = HOME .. "/.local/state/nvim/nvim.log"

local function mkdir_p(path)
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end

  local current = path:sub(1, 1) == "/" and "/" or ""
  for _, part in ipairs(parts) do
    current = current .. part .. "/"
    local ok, err = pcall(stat.mkdir, current, tonumber("755", 8))
    if not ok and not err:match("File exists") then
      return nil, "failed to create directory " .. current .. ": " .. tostring(err)
    end
  end
  return true
end

local function file_exists(path)
  local ok, s = pcall(stat.stat, path)
  return ok and s ~= nil
end

local function read_file(path)
  local f = io.open(path, "r")
  if not f then
    return nil
  end
  local content = f:read("*all")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "w")
  if not f then
    return nil, "failed to write file: " .. path
  end
  f:write(content)
  f:close()
  return true
end

local function is_process_running(pid)
  return signal.kill(pid, 0) == 0
end

local function get_running_pid()
  local pid_str = read_file(PIDFILE)
  if not pid_str then
    return nil
  end
  local pid = tonumber(pid_str)
  if pid and is_process_running(pid) then
    return pid
  end
  return nil
end

local function wait_for_socket(socket_path, timeout)
  timeout = timeout or 5
  local sleep_interval = 0.1
  local elapsed = 0

  while elapsed < timeout do
    if file_exists(socket_path) then
      local socket = require("posix.sys.socket")
      local sock_fd = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
      if sock_fd and sock_fd >= 0 then
        local sockaddr = {
          family = socket.AF_UNIX,
          path = socket_path
        }
        local ok = socket.connect(sock_fd, sockaddr)
        unistd.close(sock_fd)
        if ok == 0 then
          return true
        end
      end
    end

    unistd.sleep(sleep_interval)
    elapsed = elapsed + sleep_interval
  end

  return false
end

local function acquire_pidfile_lock()
  local lockfd = fcntl.open(PIDFILE, fcntl.O_RDWR + fcntl.O_CREAT, tonumber("644", 8))
  if not lockfd or lockfd < 0 then
    return nil, "failed to open pidfile for locking"
  end

  local lock = ffi.new("struct flock")
  lock.l_start = 0
  lock.l_len = 0
  lock.l_pid = 0
  lock.l_type = fcntl.F_WRLCK
  lock.l_whence = unistd.SEEK_SET

  local ret = ffi.C.fcntl(lockfd, fcntl.F_SETLK, lock)
  if ret == -1 then
    local errno = ffi.errno()
    unistd.close(lockfd)
    return nil, string.format("another instance is starting (errno: %d)", errno)
  end

  return lockfd
end

local function release_pidfile_lock(lockfd)
  if lockfd then
    unistd.close(lockfd)
  end
end

local function load_zsh_environment()
  local posix = require("posix")
  local handle = posix.popen({"zsh", "-i", "-l", "-c", "env -0"}, "r")
  if not handle then
    return
  end

  local output = unistd.read(handle.fd, 65536) or ""
  wait.wait(handle.pids[1])
  unistd.close(handle.fd)

  local i = 1
  while i <= #output do
    local next_null = output:find("\0", i, true)
    if not next_null then
      break
    end
    local line = output:sub(i, next_null - 1)
    local key, value = line:match("^([^=]+)=(.*)$")
    if key then
      stdlib.setenv(key, value)
    end
    i = next_null + 1
  end
end

local function setup_nvim_environment()
  load_zsh_environment()
  stdlib.setenv("NVIM_SERVER_MODE", "1")
end

local function exec_nvim_server()
  os.remove(SOCK)
  unistd.execp(NVIM_BIN, {NVIM_BIN, "--listen", SOCK, "--headless"})
end

local function cmd_serve()
  setup_nvim_environment()
  exec_nvim_server()
end

local function cmd_start()
  local ok, err = mkdir_p(PIDFILE:match("(.+)/[^/]+$"))
  if not ok then
    io.stderr:write("error: " .. err .. "\n")
    return 1
  end
  ok, err = mkdir_p(LOGFILE:match("(.+)/[^/]+$"))
  if not ok then
    io.stderr:write("error: " .. err .. "\n")
    return 1
  end

  local lockfd
  lockfd, err = acquire_pidfile_lock()
  if not lockfd then
    io.stderr:write("failed to acquire lock: " .. err .. "\n")
    return 1
  end

  local pid = get_running_pid()
  if pid then
    release_pidfile_lock(lockfd)
    io.write("nvim server already running\n")
    return 0
  end

  os.remove(SOCK)

  local child_pid = unistd.fork()
  if child_pid == 0 then
    ffi.C.setsid()

    local grandchild_pid = unistd.fork()
    if grandchild_pid == 0 then
      local logfd = fcntl.open(LOGFILE, fcntl.O_WRONLY + fcntl.O_CREAT + fcntl.O_APPEND, tonumber("644", 8))
      if logfd then
        unistd.dup2(logfd, unistd.STDOUT_FILENO)
        unistd.dup2(logfd, unistd.STDERR_FILENO)
        unistd.close(logfd)
      end

      local devnull = fcntl.open("/dev/null", fcntl.O_RDONLY)
      if devnull then
        unistd.dup2(devnull, unistd.STDIN_FILENO)
        unistd.close(devnull)
      end

      for fd = 3, 255 do
        pcall(unistd.close, fd)
      end

      unistd.chdir(HOME)
      setup_nvim_environment()
      exec_nvim_server()
      os.exit(1)
    else
      local ok, err = write_file(PIDFILE, tostring(grandchild_pid))
      if not ok then
        io.stderr:write("error: " .. err .. "\n")
        release_pidfile_lock(lockfd)
        os.exit(1)
      end
      release_pidfile_lock(lockfd)
      os.exit(0)
    end
  else
    wait.wait(child_pid)

    if wait_for_socket(SOCK, 5) then
      pid = get_running_pid()
      if pid then
        io.write("nvim server started\n")
        return 0
      else
        io.stderr:write("nvim server process died after starting, check " .. LOGFILE .. "\n")
        os.remove(PIDFILE)
        return 1
      end
    else
      io.stderr:write("nvim server failed to start: socket not ready after 5 seconds, check " .. LOGFILE .. "\n")
      pid = get_running_pid()
      if pid then
        signal.kill(pid, signal.SIGTERM)
      end
      os.remove(PIDFILE)
      return 1
    end
  end
end

local function cmd_stop()
  local pid = get_running_pid()
  if pid then
    signal.kill(pid, signal.SIGTERM)
    os.remove(PIDFILE)
    io.write("nvim server stopped\n")
  else
    io.write("nvim server not running\n")
  end
  os.remove(SOCK)
  return 0
end

local function cmd_status()
  local pid = get_running_pid()
  if pid then
    io.write(string.format("nvim server is running (pid %d)\n", pid))
    return 0
  else
    io.write("nvim server is not running\n")
    return 1
  end
end

local function is_systemd_running()
  return file_exists("/run/systemd/system")
end

local function run_command(args)
  local posix = require("posix")
  local handle = posix.popen(args, "r")
  if not handle then
    return 1
  end
  local _, reason, status = wait.wait(handle.pids[1])
  unistd.close(handle.fd)
  if reason == "exited" then
    return status
  end
  return 1
end

local function cmd_reload()
  if jit.os == "OSX" then
    local uid = unistd.getuid()
    run_command({"launchctl", "bootout", "gui/" .. uid .. "/com.user.nvim"})
    unistd.sleep(0.5)
    local status = run_command({"launchctl", "bootstrap", "gui/" .. uid, HOME .. "/Library/LaunchAgents/com.user.nvim.plist"})
    if status ~= 0 then
      io.stderr:write("failed to bootstrap nvim service\n")
      return 1
    end
    status = run_command({"launchctl", "enable", "gui/" .. uid .. "/com.user.nvim"})
    if status ~= 0 then
      io.stderr:write("failed to enable nvim service\n")
      return 1
    end
    status = run_command({"launchctl", "kickstart", "gui/" .. uid .. "/com.user.nvim"})
    if status ~= 0 then
      io.stderr:write("failed to kickstart nvim service\n")
      return 1
    end
    io.write("nvim service reloaded\n")
  else
    if is_systemd_running() then
      local status = run_command({"systemctl", "--user", "daemon-reload"})
      if status ~= 0 then
        io.stderr:write("failed to reload systemd daemon\n")
        return 1
      end
      io.write("systemd daemon reloaded\n")
    end
  end
  return 0
end

local function cmd_restart()
  if jit.os == "OSX" then
    local uid = unistd.getuid()
    local status = run_command({"launchctl", "kickstart", "-k", "gui/" .. uid .. "/com.user.nvim"})
    if status ~= 0 then
      io.stderr:write("failed to restart nvim service\n")
      return 1
    end
    io.write("nvim service restarted\n")
  else
    if is_systemd_running() then
      local status = run_command({"systemctl", "--user", "restart", "nvim"})
      if status ~= 0 then
        io.stderr:write("failed to restart nvim service\n")
        return 1
      end
      io.write("nvim service restarted\n")
    else
      cmd_stop()
      unistd.sleep(1)
      return cmd_start()
    end
  end
  return 0
end

local function cmd_cleanup()
  os.remove(SOCK)
  return 0
end

local commands = {
  serve = cmd_serve,
  start = cmd_start,
  stop = cmd_stop,
  status = cmd_status,
  reload = cmd_reload,
  restart = cmd_restart,
  cleanup = cmd_cleanup,
}

local function daemon_mode(args)
  local command = args[1] or ""
  local cmd_fn = commands[command]

  if cmd_fn then
    return cmd_fn()
  else
    io.stderr:write("nvimd: unknown command: " .. command .. "\n")
    io.stderr:write("Usage: nvimd {serve|start|stop|status|restart|reload|cleanup}\n")
    return 1
  end
end

local function client_mode(args)
  local nvim_invim = os.getenv("NVIM_INVIM")
  local nvim_server_mode = os.getenv("NVIM_SERVER_MODE")

  if not nvim_invim and not nvim_server_mode then
    local new_args = {NVIM_BIN, "--server", SOCK}
    for _, arg in ipairs(args) do
      table.insert(new_args, arg)
    end
    unistd.execp(NVIM_BIN, new_args)
  else
    local new_args = {NVIM_BIN}
    for _, arg in ipairs(args) do
      table.insert(new_args, arg)
    end
    unistd.execp(NVIM_BIN, new_args)
  end
end

local function cleanup_and_exit(signum)
  os.remove(SOCK)
  if file_exists(PIDFILE) then
    local pid = get_running_pid()
    if not pid then
      os.remove(PIDFILE)
    end
  end
  os.exit(128 + signum)
end

local function main(args)
  signal.signal(signal.SIGINT, function() cleanup_and_exit(signal.SIGINT) end)
  signal.signal(signal.SIGTERM, function() cleanup_and_exit(signal.SIGTERM) end)

  local program_name = args[0]:match("([^/]+)$")

  if program_name == "nvimd" or program_name == "nvimd.lua" then
    local cmd_args = {}
    for i = 1, #args do
      cmd_args[i] = args[i]
    end
    return daemon_mode(cmd_args)
  else
    local cmd_args = {}
    for i = 1, #args do
      cmd_args[i] = args[i]
    end
    return client_mode(cmd_args)
  end
end

local args = {[0] = arg[0]}
for i = 1, #arg do
  args[i] = arg[i]
end

local ok, result = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(result) .. "\n")
  os.exit(1)
end

os.exit(result or 0)
