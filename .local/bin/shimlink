#!/usr/bin/env lua

local shimlink = require("shimlink")
local platform = require("platform")
local file = require("file")
local signal = require("posix.signal")

local cleanup_registry = {
  temp_dirs = {},
}

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function register_temp_dir(path)
  if path then
    table.insert(cleanup_registry.temp_dirs, path)
  end
end

local function cleanup_temp_resources()
  for _, temp_dir in ipairs(cleanup_registry.temp_dirs) do
    if temp_dir and file.exists(temp_dir) then
      local ok, err = file.rm_rf(temp_dir)
      if not ok then
        stderr_write("shimlink: warning: failed to cleanup temp directory during signal handling: " .. tostring(err))
      end
    end
  end
  cleanup_registry.temp_dirs = {}
end

local function setup_signal_handlers()
  local function signal_handler(signum)
    stderr_write("\nshimlink: received signal " .. signum .. ", cleaning up...")
    cleanup_temp_resources()
    os.exit(128 + signum)
  end

  signal.signal(signal.SIGINT, signal_handler)
  signal.signal(signal.SIGTERM, signal_handler)
end


local function parse_params(args)
  local params = {}
  for _, arg in ipairs(args) do
    local key, value = arg:match("^([^=]+)=(.+)$")
    if key and value then
      params[key] = value
    end
  end
  return params
end

local function get_nested(tbl, path)
  local keys = {}
  for key in path:gmatch("[^.]+") do
    table.insert(keys, key)
  end

  local current = tbl
  for i = 1, #keys do
    local key = keys[i]
    if type(current) ~= "table" then
      return nil, "not a table at key: " .. key
    end
    current = current[key]
    if current == nil then
      return nil, "field not found: " .. path
    end
  end

  return current
end

local function set_nested(tbl, path, value)
  local keys = {}
  for key in path:gmatch("[^.]+") do
    table.insert(keys, key)
  end

  local current = tbl
  for i = 1, #keys - 1 do
    local key = keys[i]
    if not current[key] then
      current[key] = {}
    end
    current = current[key]
  end

  current[keys[#keys]] = value
end

local function apply_updates(config, params)
  local platform = params.platform
  local version = params.version
  local sha = params.sha

  if version then
    config.version = version
  end

  if platform and sha then
    if not config.platforms[platform] then
      config.platforms[platform] = {}
    end
    config.platforms[platform].sha256 = sha
  end

  for key, value in pairs(params) do
    if key ~= "platform" and key ~= "version" and key ~= "sha" then
      set_nested(config, key, value)
    end
  end

  return config
end

local function cmd_show(args)
  if #args < 1 then
    error("usage: shimlink show <executable>[.<field>] [key=value...]")
  end

  local first_arg = args[1]
  local executable, field_path = first_arg:match("^([^.]+)%.(.+)$")

  if not executable then
    executable = first_arg
    field_path = nil
  end

  local params = parse_params({unpack(args, 2)})

  local config = shimlink.load_config(executable)
  config = apply_updates(config, params)
  config = platform.expand(config)

  -- Remove metadata before rendering
  local clean = {}
  for k, v in pairs(config) do
    if k ~= "_meta" then
      clean[k] = v
    end
  end

  if field_path then
    local plat = params.platform or platform.detect()
    local value, err = platform.get_field(clean, field_path, plat)
    if not value then
      error(err)
    end

    if type(value) == "table" then
      print(platform.render(value))
    else
      print(tostring(value))
    end
  else
    print(platform.render(clean))
  end
end

local function cmd_write(args)
  if #args < 1 then
    error("usage: shimlink write <executable> [key=value...]")
  end

  local executable = args[1]
  local params = parse_params({unpack(args, 2)})

  local config = platform.get(executable)
  if not config then
    error("config not found for: " .. executable)
  end
  config = apply_updates(config, params)

  -- Get source from metadata
  local source = config._meta.source

  -- Reload file with custom callback to preserve order and replace updated config
  local reloaded = {}
  local kinds = {
    Version = function(cfg)
      if cfg.name == config.name then
        table.insert(reloaded, config)
      else
        table.insert(reloaded, cfg)
      end
    end
  }

  platform.load_file(source, kinds)

  -- Build output by concatenating rendered configs
  local output = {}
  for _, cfg in ipairs(reloaded) do
    table.insert(output, platform.write(cfg))
  end

  -- Write to file
  local f = io.open(source, "w")
  if not f then
    error("failed to open " .. source)
  end
  f:write(table.concat(output, "\n"))
  f:close()

  print("updated " .. source)
  if params.version then
    print("  version: " .. params.version)
  end
  if params.platform and params.sha then
    print("  " .. params.platform .. ": " .. params.sha:sub(1, 16) .. "...")
  end
end

local function cmd_help()
  print([[shimlink - symlink-based executable manager

usage:
  shimlink show <executable> [key=value...]
    show config with optional updates applied (does not persist)

  shimlink write <executable> [key=value...]
    update config and persist to disk

  shimlink update <executable>... [-f|--force]
    download and install executables to versioned directories
    creates symlinks in ~/.local/share/shimlink/bin/

options:
  -f, --force    skip checksum validation and update config with new checksum

special parameters (show/write):
  platform=X  - target platform for sha updates
  version=Y   - update version (regenerates all URLs)
  sha=Z       - update sha256 for platform (requires platform=)

examples:
  shimlink show nvim
  shimlink show nvim version=2025.11.24
  shimlink write nvim platform=darwin-arm64 version=2025.11.24 sha=abc123...
  shimlink write nvim version=2025.11.24
  shimlink update nvim
  shimlink update nvim -f
  shimlink update nvim luajit tree-sitter
]])
end

local function cmd_update(args)
  local force = false
  local executables = {}

  local i = 1
  while i <= #args do
    if args[i] == "-f" or args[i] == "--force" then
      force = true
    elseif args[i] == "-h" or args[i] == "--help" then
      cmd_help()
      os.exit(0)
    else
      table.insert(executables, args[i])
    end
    i = i + 1
  end

  if #executables == 0 then
    stderr_write("shimlink: update requires at least one executable name")
    os.exit(1)
  end

  local failed = false
  for _, executable in ipairs(executables) do
    local ok, err = pcall(function()
      local config = shimlink.load_config(executable)
      config = platform.expand(config)
      if not shimlink.update_executable(executable, config, force, register_temp_dir) then
        stderr_write("shimlink: failed to update " .. executable)
        failed = true
      end
    end)
    if not ok then
      stderr_write("shimlink: error updating " .. executable .. ": " .. tostring(err))
      failed = true
    end
  end

  if failed then
    os.exit(1)
  end
  os.exit(0)
end

local function main(args)
  setup_signal_handlers()

  if #args == 0 or args[1] == "help" or args[1] == "--help" then
    cmd_help()
    os.exit(0)
  end

  shimlink.load_all_configs()

  local command = args[1]
  local cmd_args = {unpack(args, 2)}

  if command == "show" then
    cmd_show(cmd_args)
  elseif command == "write" then
    cmd_write(cmd_args)
  elseif command == "update" then
    cmd_update(cmd_args)
  else
    error("unknown command: " .. command)
  end
end

local args = {...}
local ok, err = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(err) .. "\n")
  os.exit(1)
end
