#!/usr/bin/env luajit

local platform = require("platform")
local ffi = require("ffi")
local posix = require("posix")
local unistd = require("posix.unistd")
local stat = require("posix.sys.stat")
local dirent = require("posix.dirent")
local openssl = require("openssl")
local digest = require("openssl.digest")

ffi.cdef([[
  typedef struct { long tv_sec; long tv_usec; } timeval;
  int symlink(const char *target, const char *linkpath);
  int unlink(const char *pathname);
]])

local function config_dir()
  return os.getenv("HOME") .. "/.config/shimlink"
end

local function get_version_files()
  local entries = dirent.dir(config_dir())
  local files = {}

  for _, entry in ipairs(entries) do
    if entry:match("%.lua$") then
      table.insert(files, config_dir() .. "/" .. entry)
    end
  end

  return files
end

local function load_all_configs()
  for _, path in ipairs(get_version_files()) do
    local ok, err = platform.load_file(path)
    if not ok then
      error("failed to load " .. path .. ": " .. tostring(err))
    end
  end
end

local function load_config(executable)
  local config = platform.get(executable)
  if not config then
    error("config not found for: " .. executable)
  end
  return config
end

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function file_exists(path)
  local st = stat.stat(path)
  return st ~= nil
end

local function is_directory(path)
  local st = stat.stat(path)
  if not st then return false end
  return stat.S_ISDIR(st.st_mode) ~= 0
end

local function read_file(path)
  local f = io.open(path, "rb")
  if not f then
    return nil
  end
  local content = f:read("*all")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "wb")
  if not f then
    return false
  end
  f:write(content)
  f:close()
  return true
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function path_join(...)
  local parts = { ... }
  return table.concat(parts, "/")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

local function mkdir_p(path)
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end

  local current = path:sub(1, 1) == "/" and "/" or ""
  for _, part in ipairs(parts) do
    current = current .. part
    if not is_directory(current) then
      stat.mkdir(current, tonumber("0755", 8))
    end
    current = current .. "/"
  end
end

local function rm_rf(path)
  if not file_exists(path) and not is_directory(path) then
    return true
  end

  local function remove_recursive(p)
    if is_directory(p) then
      local entries = dirent.dir(p)
      for _, entry in ipairs(entries) do
        if entry ~= "." and entry ~= ".." then
          remove_recursive(path_join(p, entry))
        end
      end
      unistd.rmdir(p)
    else
      ffi.C.unlink(p)
    end
  end

  remove_recursive(path)
  return true
end

local function basename(path)
  return path:match("([^/]+)$") or path
end

local function dirname(path)
  local dir = path:match("(.+)/[^/]+$")
  return dir or "."
end

local function list_dir_first_entry(path)
  local entries = dirent.dir(path)
  for _, entry in ipairs(entries) do
    if entry ~= "." and entry ~= ".." then
      return entry
    end
  end
  return nil
end

local function calculate_sha256(filepath)
  local f = io.open(filepath, "rb")
  if not f then return nil end

  local md = digest.new("sha256")
  while true do
    local chunk = f:read(8192)
    if not chunk then break end
    md:update(chunk)
  end
  f:close()

  local hash = md:final()
  return hash:gsub(".", function(c) return string.format("%02x", string.byte(c)) end)
end

local function get_shimlink_root()
  return path_join(get_home_dir(), ".local", "share", "shimlink")
end

local function get_storage_dir(executable_name)
  if executable_name then
    return path_join(get_shimlink_root(), "_", executable_name)
  end
  return path_join(get_shimlink_root(), "_")
end

local function get_versioned_dir(executable_name, sha256)
  return path_join(get_storage_dir(executable_name), sha256:sub(1, 16))
end

local function get_shimlink_bin_dir()
  return path_join(get_shimlink_root(), "bin")
end

local function get_shimlink_bin_link(executable_name)
  return path_join(get_shimlink_bin_dir(), executable_name)
end

local function download_file(url, dest_path)
  stderr_write("shimlink: downloading " .. url)

  local http_request = require("http.request")

  local req = http_request.new_from_uri(url)
  req.headers:upsert(":method", "GET")
  req.headers:upsert("user-agent", "shimlink/1.0")

  local headers, stream = req:go()
  if not headers then
    stderr_write("shimlink: failed to connect: " .. tostring(stream))
    return false
  end

  local status = headers:get(":status")
  if status ~= "200" then
    stderr_write("shimlink: http error " .. status)
    return false
  end

  local body, err = stream:get_body_as_string()
  if not body then
    stderr_write("shimlink: failed to read response: " .. tostring(err))
    return false
  end

  local f = io.open(dest_path, "wb")
  if not f then
    stderr_write("shimlink: failed to open " .. dest_path)
    return false
  end
  f:write(body)
  f:close()

  return true
end

local function extract_archive(archive_path, extract_to, executable_path)
  local archive_name = basename(archive_path)

  if archive_name:match("%.zip$") then
    local exit_status = posix.spawn({"unzip", "-q", archive_path, "-d", extract_to})
    if exit_status ~= 0 then
      return nil, "failed to extract zip"
    end
  elseif archive_name:match("%.tar%.gz$") or archive_name:match("%.tgz$") then
    local exit_status = posix.spawn({"tar", "-xzf", archive_path, "-C", extract_to})
    if exit_status ~= 0 then
      return nil, "failed to extract tar.gz"
    end
  elseif archive_name:match("%.gz$") and not archive_name:match("%.tar%.gz$") then
    if not executable_path then
      return nil, "executable_path required for single file gzip"
    end
    local output_path = path_join(extract_to, executable_path)
    mkdir_p(dirname(output_path))
    local exit_status = posix.spawn({"/bin/sh", "-c", string.format("gunzip -c %q > %q", archive_path, output_path)})
    if exit_status ~= 0 then
      return nil, "failed to extract gzip"
    end
    return output_path
  else
    return nil, "unsupported archive format: " .. archive_path
  end

  if executable_path then
    return path_join(extract_to, executable_path)
  else
    return archive_path
  end
end

local function create_symlink_atomic(target, link_path)
  local temp_link = string.format("%s.tmp.%d.%d", link_path, os.time(), unistd.getpid())

  local cleanup = function()
    ffi.C.unlink(temp_link)
  end

  local ok, err = pcall(function()
    mkdir_p(dirname(link_path))

    cleanup()

    local result = ffi.C.symlink(target, temp_link)
    if result ~= 0 then
      error(string.format("failed to create temporary symlink %s -> %s", temp_link, target))
    end

    local rename_result = os.rename(temp_link, link_path)
    if not rename_result then
      error(string.format("failed to rename symlink %s to %s", temp_link, link_path))
    end
  end)

  if not ok then
    cleanup()
    stderr_write("shimlink: " .. tostring(err))
    return false
  end

  return true
end

local function create_symlink(bin_dir, src_path, dest_path, executable_name)
  local source = path_join(bin_dir, src_path)

  if not file_exists(source) then
    stderr_write("shimlink: warning: symlink source does not exist: " .. source)
    return
  end

  local dest = expand_path(dest_path)

  mkdir_p(dirname(dest))

  if file_exists(dest) then
    ffi.C.unlink(dest)
  end

  local result = ffi.C.symlink(source, dest)
  if result == 0 then
    stderr_write("shimlink: created symlink " .. dest .. " -> " .. source)
  else
    stderr_write("shimlink: warning: failed to create symlink " .. dest)
  end
end

local function get_executables(config)
  if config.executables then
    return config.executables
  else
    return {{
      name = config.name,
      path = config.path,
      symlinks = config.symlinks,
      exec = config.exec,
    }}
  end
end

local function update_config_checksum(executable_name, plat, new_sha)
  local config = platform.get(executable_name)
  if not config then
    stderr_write("shimlink: config not found for " .. executable_name)
    return false
  end

  if not config.platforms[plat] then
    config.platforms[plat] = {}
  end
  config.platforms[plat].sha256 = new_sha

  -- Get source from metadata
  local source = config._meta.source

  -- Reload file with custom callback to preserve order and replace updated config
  local reloaded = {}
  local kinds = {
    Version = function(cfg)
      if cfg.name == config.name then
        table.insert(reloaded, config)
      else
        table.insert(reloaded, cfg)
      end
    end
  }

  platform.load_file(source, kinds)

  -- Build output by concatenating rendered configs
  local output = {}
  for _, cfg in ipairs(reloaded) do
    table.insert(output, platform.write(cfg))
  end

  -- Write to file
  local f = io.open(source, "w")
  if not f then
    stderr_write("shimlink: failed to open " .. source .. " for writing")
    return false
  end
  f:write(table.concat(output, "\n"))
  f:close()

  stderr_write("shimlink: updated checksum for " .. executable_name .. " (" .. plat .. ") to " .. new_sha)
  return true
end

local function download_executable(executable_name, config, force)
  local url = config.url
  local expected_sha256 = config.sha256
  local path = config.path

  local shimlink_root = get_shimlink_root()
  mkdir_p(shimlink_root)

  local stdlib = require("posix.stdlib")
  local temp_template = path_join(shimlink_root, ".tmp." .. executable_name .. ".XXXXXX")
  local temp_dir = stdlib.mkdtemp(temp_template)

  local success, result = pcall(function()
    local download_name = basename(url)
    local download_path = path_join(temp_dir, download_name)

    if not download_file(url, download_path) then
      error("failed to download " .. executable_name)
    end

    local actual_sha256 = calculate_sha256(download_path)

    local extract_temp

    if path then
      extract_temp = path_join(temp_dir, "extracted")
      mkdir_p(extract_temp)
      local err
      local extracted_path
      extracted_path, err = extract_archive(download_path, extract_temp, path)
      if not extracted_path then
        error("failed to extract " .. executable_name .. ": " .. err)
      end

      local strip_components = config.strip_components or 0
      local binary_dir = extract_temp
      for i = 1, strip_components do
        local first_entry = list_dir_first_entry(binary_dir)
        if first_entry then
          binary_dir = path_join(binary_dir, first_entry)
        end
      end
      local executable_path = path_join(binary_dir, path)

      if file_exists(executable_path) then
        stat.chmod(executable_path, tonumber("0755", 8))
      end
    else
      extract_temp = temp_dir
      if file_exists(download_path) then
        stat.chmod(download_path, tonumber("0755", 8))
      end
    end

    if force then
      update_config_checksum(executable_name, config.platform, actual_sha256)
      stderr_write("shimlink: force mode - updated checksum for " .. executable_name)
    elseif expected_sha256 then
      if actual_sha256 ~= expected_sha256 then
        stderr_write("shimlink: checksum mismatch for " .. executable_name)
        stderr_write("shimlink:   expected: " .. expected_sha256)
        stderr_write("shimlink:   actual:   " .. actual_sha256)
        error("checksum mismatch")
      end
    end

    local versioned_dir = get_versioned_dir(executable_name, actual_sha256)
    local storage_dir = get_storage_dir(executable_name)
    mkdir_p(storage_dir)

    if is_directory(versioned_dir) then
      stderr_write("shimlink: version " .. actual_sha256:sub(1, 16) .. " already exists")
      return actual_sha256
    end

    local install_temp = path_join(temp_dir, "install")

    if path then
      local strip_components = config.strip_components or 0

      if strip_components > 0 then
        local source_dir = extract_temp
        for i = 1, strip_components do
          local first_entry = list_dir_first_entry(source_dir)
          if first_entry then
            source_dir = path_join(source_dir, first_entry)
          else
            stderr_write("shimlink: warning: cannot strip " .. i .. " components, directory empty")
            break
          end
        end
        local ok, err = os.rename(source_dir, install_temp)
        if not ok then
          error("failed to prepare installation directory: " .. tostring(err))
        end
      else
        local ok, err = os.rename(extract_temp, install_temp)
        if not ok then
          error("failed to prepare installation directory: " .. tostring(err))
        end
      end
    else
      mkdir_p(install_temp)
      local final_path = path_join(install_temp, executable_name)
      local ok, err = os.rename(download_path, final_path)
      if not ok then
        error("failed to move executable: " .. tostring(err))
      end
    end

    local temp_versioned = path_join(storage_dir, ".installing." .. actual_sha256:sub(1, 16))
    local ok, err = os.rename(install_temp, temp_versioned)
    if not ok then
      error("failed to create temporary versioned directory: " .. tostring(err))
    end

    ok, err = os.rename(temp_versioned, versioned_dir)
    if not ok then
      rm_rf(temp_versioned)
      error("failed to finalize installation: " .. tostring(err))
    end

    stderr_write("shimlink: installed " .. executable_name .. " version " .. actual_sha256:sub(1, 16))

    return actual_sha256
  end)

  rm_rf(temp_dir)

  if not success then
    stderr_write("shimlink: " .. tostring(result))
    return false
  end

  return true, result
end

local function update_executable(executable_name, config, force)
  local plat = platform.detect()
  local platform_config, err = platform.get_config(config, plat)
  if not platform_config then
    stderr_write("shimlink: " .. err)
    return false
  end

  local executables = get_executables(platform_config)

  local sha256
  local expected_sha256 = platform_config.sha256
  if expected_sha256 and not force then
    local versioned_dir = get_versioned_dir(executable_name, expected_sha256)
    if is_directory(versioned_dir) then
      stderr_write("shimlink: version " .. expected_sha256:sub(1, 16) .. " already exists")
      sha256 = expected_sha256
    end
  end

  if not sha256 then
    local success
    local urls = config.urls or {}
    platform_config.url = urls[plat] or config.url
    success, sha256 = download_executable(executable_name, platform_config, force)
    if not success then
      return false
    end
  end

  local versioned_dir = get_versioned_dir(executable_name, sha256)

  for _, executable_config in ipairs(executables) do
    local executable_name_inner = executable_config.name
    local executable_path_config = executable_config.path
    local executable_symlinks = executable_config.symlinks

    local executable_full_path
    if executable_path_config then
      executable_full_path = path_join(versioned_dir, executable_path_config)
    else
      executable_full_path = path_join(versioned_dir, executable_name_inner)
    end

    if not file_exists(executable_full_path) then
      stderr_write("shimlink: executable not found at " .. executable_full_path)
      return false
    end

    local shimlink_bin_link = get_shimlink_bin_link(executable_name_inner)
    local short_sha = sha256:sub(1, 16)

    local relative_to_versioned
    if executable_path_config then
      relative_to_versioned = path_join("..", "_", executable_name, short_sha, executable_path_config)
    else
      relative_to_versioned = path_join("..", "_", executable_name, short_sha, executable_name_inner)
    end

    if not create_symlink_atomic(relative_to_versioned, shimlink_bin_link) then
      stderr_write("shimlink: failed to create shimlink bin link for " .. executable_name_inner)
      return false
    end
    stderr_write("shimlink: updated " .. shimlink_bin_link .. " -> " .. relative_to_versioned)

    if executable_symlinks then
      for src_path, dest_path in pairs(executable_symlinks) do
        create_symlink(versioned_dir, src_path, dest_path, executable_name_inner)
      end
    end
  end

  return true
end

local function parse_params(args)
  local params = {}
  for _, arg in ipairs(args) do
    local key, value = arg:match("^([^=]+)=(.+)$")
    if key and value then
      params[key] = value
    end
  end
  return params
end

local function get_nested(tbl, path)
  local keys = {}
  for key in path:gmatch("[^.]+") do
    table.insert(keys, key)
  end

  local current = tbl
  for i = 1, #keys do
    local key = keys[i]
    if type(current) ~= "table" then
      return nil
    end
    current = current[key]
    if current == nil then
      return nil
    end
  end

  return current
end

local function set_nested(tbl, path, value)
  local keys = {}
  for key in path:gmatch("[^.]+") do
    table.insert(keys, key)
  end

  local current = tbl
  for i = 1, #keys - 1 do
    local key = keys[i]
    if not current[key] then
      current[key] = {}
    end
    current = current[key]
  end

  current[keys[#keys]] = value
end

local function apply_updates(config, params)
  local platform = params.platform
  local version = params.version
  local sha = params.sha

  if version then
    config.version = version
  end

  if platform and sha then
    if not config.platforms[platform] then
      config.platforms[platform] = {}
    end
    config.platforms[platform].sha256 = sha
  end

  for key, value in pairs(params) do
    if key ~= "platform" and key ~= "version" and key ~= "sha" then
      set_nested(config, key, value)
    end
  end

  return config
end

local function cmd_show(args)
  if #args < 1 then
    error("usage: shimlink show <executable>[.<field>] [key=value...]")
  end

  local first_arg = args[1]
  local executable, field_path = first_arg:match("^([^.]+)%.(.+)$")

  if not executable then
    executable = first_arg
    field_path = nil
  end

  local params = parse_params({unpack(args, 2)})

  local config = load_config(executable)
  config = apply_updates(config, params)
  config = platform.expand(config, params.platform)

  -- Remove metadata before rendering
  local clean = {}
  for k, v in pairs(config) do
    if k ~= "_meta" then
      clean[k] = v
    end
  end

  if field_path then
    local plat = params.platform or platform.detect()
    local value, err = platform.get_field(clean, field_path, plat)
    if not value then
      error(err)
    end

    if type(value) == "table" then
      print(platform.render(value))
    else
      print(tostring(value))
    end
  else
    print(platform.render(clean))
  end
end

local function cmd_write(args)
  if #args < 1 then
    error("usage: shimlink write <executable> [key=value...]")
  end

  local executable = args[1]
  local params = parse_params({unpack(args, 2)})

  local config = platform.get(executable)
  if not config then
    error("config not found for: " .. executable)
  end
  config = apply_updates(config, params)

  -- Get source from metadata
  local source = config._meta.source

  -- Reload file with custom callback to preserve order and replace updated config
  local reloaded = {}
  local kinds = {
    Version = function(cfg)
      if cfg.name == config.name then
        table.insert(reloaded, config)
      else
        table.insert(reloaded, cfg)
      end
    end
  }

  platform.load_file(source, kinds)

  -- Build output by concatenating rendered configs
  local output = {}
  for _, cfg in ipairs(reloaded) do
    table.insert(output, platform.write(cfg))
  end

  -- Write to file
  local f = io.open(source, "w")
  if not f then
    error("failed to open " .. source)
  end
  f:write(table.concat(output, "\n"))
  f:close()

  print("updated " .. source)
  if params.version then
    print("  version: " .. params.version)
  end
  if params.platform and params.sha then
    print("  " .. params.platform .. ": " .. params.sha:sub(1, 16) .. "...")
  end
end

local function cmd_help()
  print([[shimlink - symlink-based executable manager

usage:
  shimlink show <executable> [key=value...]
    show config with optional updates applied (does not persist)

  shimlink write <executable> [key=value...]
    update config and persist to disk

  shimlink update <executable>... [-f|--force]
    download and install executables to versioned directories
    creates symlinks in ~/.local/share/shimlink/bin/

options:
  -f, --force    skip checksum validation and update config with new checksum

special parameters (show/write):
  platform=X  - target platform for sha updates
  version=Y   - update version (regenerates all URLs)
  sha=Z       - update sha256 for platform (requires platform=)

examples:
  shimlink show nvim
  shimlink show nvim version=2025.11.24
  shimlink write nvim platform=darwin-arm64 version=2025.11.24 sha=abc123...
  shimlink write nvim version=2025.11.24
  shimlink update nvim
  shimlink update nvim -f
  shimlink update nvim luajit tree-sitter
]])
end

local function cmd_update(args)
  local force = false
  local executables = {}

  local i = 1
  while i <= #args do
    if args[i] == "-f" or args[i] == "--force" then
      force = true
    elseif args[i] == "-h" or args[i] == "--help" then
      cmd_help()
      os.exit(0)
    else
      table.insert(executables, args[i])
    end
    i = i + 1
  end

  if #executables == 0 then
    stderr_write("shimlink: update requires at least one executable name")
    os.exit(1)
  end

  local failed = false
  for _, executable in ipairs(executables) do
    local ok, err = pcall(function()
      local config = load_config(executable)
      config = platform.expand(config)
      if not update_executable(executable, config, force) then
        stderr_write("shimlink: failed to update " .. executable)
        failed = true
      end
    end)
    if not ok then
      stderr_write("shimlink: error updating " .. executable .. ": " .. tostring(err))
      failed = true
    end
  end

  if failed then
    os.exit(1)
  end
  os.exit(0)
end

local function main(args)
  if #args == 0 or args[1] == "help" or args[1] == "--help" then
    cmd_help()
    os.exit(0)
  end

  load_all_configs()

  local command = args[1]
  local cmd_args = {unpack(args, 2)}

  if command == "show" then
    cmd_show(cmd_args)
  elseif command == "write" then
    cmd_write(cmd_args)
  elseif command == "update" then
    cmd_update(cmd_args)
  else
    error("unknown command: " .. command)
  end
end

local args = {...}
local ok, err = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(err) .. "\n")
  os.exit(1)
end
