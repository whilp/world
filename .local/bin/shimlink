#!/usr/bin/env lua-shimlink
--[[
shimlink: A symlink-based binary manager that downloads and manages binaries on demand.

When invoked through a symlink, shimlink determines the target binary name from the
symlink filename, validates the binary exists with correct checksum, downloads if needed,
then exec's the target binary with all arguments and environment passed through.
]]

local ffi = require("ffi")
local unistd = require('posix.unistd')
local stat = require('posix.sys.stat')
local openssl = require('openssl')
local digest = require('openssl.digest')

-- FFI declarations for system calls
ffi.cdef([[
  typedef struct { long tv_sec; long tv_usec; } timeval;
  int execve(const char *path, char *const argv[], char *const envp[]);
  char *getenv(const char *name);
  int symlink(const char *target, const char *linkpath);
  int unlink(const char *pathname);
  int mkdir(const char *pathname, unsigned int mode);
  int access(const char *pathname, int mode);
  int chmod(const char *pathname, unsigned int mode);
  char *realpath(const char *path, char *resolved_path);

  // uname for platform detection
  struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
  };
  int uname(struct utsname *buf);

  // environ for accessing environment variables
  extern char **environ;
]])

-- Helper functions
local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function file_exists(path)
  local st = stat.stat(path)
  return st ~= nil
end

local function is_directory(path)
  local st = stat.stat(path)
  if not st then return false end
  return stat.S_ISDIR(st.st_mode) ~= 0
end

local function read_file(path)
  local f = io.open(path, "rb")
  if not f then
    return nil
  end
  local content = f:read("*all")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "wb")
  if not f then
    return false
  end
  f:write(content)
  f:close()
  return true
end

local function get_home_dir()
  return os.getenv("HOME") or os.getenv("USERPROFILE")
end

local function path_join(...)
  local parts = { ... }
  return table.concat(parts, "/")
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    return get_home_dir() .. path:sub(2)
  end
  return path
end

local function mkdir_p(path)
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end

  local current = path:sub(1, 1) == "/" and "/" or ""
  for _, part in ipairs(parts) do
    current = current .. part
    if not is_directory(current) then
      ffi.C.mkdir(current, tonumber("0755", 8))
    end
    current = current .. "/"
  end
end

local function rm_rf(path)
  if not file_exists(path) and not is_directory(path) then
    return true
  end

  local result = os.execute(string.format("rm -rf %q", path))
  return result == 0 or result == true
end

local function basename(path)
  return path:match("([^/]+)$") or path
end

local function dirname(path)
  local dir = path:match("(.+)/[^/]+$")
  return dir or "."
end

-- Platform detection (using LuaJIT built-ins instead of FFI to avoid segfault)
local function get_platform()
  local system = jit.os:lower()
  local machine = jit.arch:lower()

  -- Normalize system names
  local system_map = {
    osx = "darwin",
  }
  system = system_map[system] or system

  -- Normalize architecture names
  local arch_map = {
    x64 = "x86_64",
    aarch64 = "arm64",
    arm64 = "arm64",
  }
  machine = arch_map[machine] or machine

  return system .. "-" .. machine
end

-- SHA256 calculation
local function calculate_sha256(filepath)
  local f = io.open(filepath, 'rb')
  if not f then return nil end

  local md = digest.new('sha256')
  while true do
    local chunk = f:read(8192)
    if not chunk then break end
    md:update(chunk)
  end
  f:close()

  -- Convert binary hash to hex string
  local hash = md:final()
  return hash:gsub('.', function(c) return string.format('%02x', string.byte(c)) end)
end

-- Configuration paths
local function get_config_dir()
  return path_join(get_home_dir(), ".config", "shimlink")
end

local function get_platform_config_path()
  return path_join(get_config_dir(), get_platform() .. ".lua")
end

local function get_shimlink_root()
  return path_join(get_home_dir(), ".local", "share", "shimlink")
end

local function get_storage_dir(binary_name)
  if binary_name then
    return path_join(get_shimlink_root(), "_", binary_name)
  end
  return path_join(get_shimlink_root(), "_")
end

local function get_versioned_dir(binary_name, sha256)
  return path_join(get_storage_dir(binary_name), sha256:sub(1, 16))
end

local function get_shimlink_bin_dir()
  return path_join(get_shimlink_root(), "bin")
end

local function get_shimlink_bin_link(binary_name)
  return path_join(get_shimlink_bin_dir(), binary_name)
end

-- Configuration loading
local function load_config()
  local config_dir = get_config_dir()
  local platform = get_platform()

  -- Check if config directory exists
  if not is_directory(config_dir) then
    stderr_write("shimlink: configuration directory not found at " .. config_dir)
    stderr_write("shimlink: create ~/.config/shimlink/ with shimlink.lua file")
    os.exit(1)
  end

  -- Try shimlink.lua first (unified config), fall back to platform-specific
  local config_path = path_join(config_dir, "shimlink.lua")
  local platform_config_path = get_platform_config_path()

  if not file_exists(config_path) then
    -- Fall back to platform-specific config for backwards compatibility
    if not file_exists(platform_config_path) then
      stderr_write("shimlink: configuration file not found")
      stderr_write("shimlink: create ~/.config/shimlink/shimlink.lua or " .. platform .. ".lua")
      os.exit(1)
    end
    config_path = platform_config_path
  end

  local func, err = loadfile(config_path)
  if not func then
    stderr_write("shimlink: failed to load " .. config_path .. ": " .. tostring(err))
    os.exit(1)
  end

  -- Pass platform as argument to config (shimlink.lua uses it, platform files ignore it)
  local ok, config = pcall(func, platform)
  if not ok then
    stderr_write("shimlink: failed to execute " .. config_path .. ": " .. tostring(config))
    os.exit(1)
  end

  if type(config) ~= "table" then
    stderr_write("shimlink: config must return a table, got " .. type(config))
    os.exit(1)
  end

  return config
end

-- Download file
local function download_file(url, dest_path)
  stderr_write("shimlink: downloading " .. url)

  local result = os.execute(string.format("curl -fsSL -A 'shimlink/1.0' -o %q %q", dest_path, url))
  return result == 0 or result == true
end

-- Extract archive
local function extract_archive(archive_path, extract_to, executable_path)
  local archive_name = basename(archive_path)

  if archive_name:match("%.zip$") then
    local result = os.execute(string.format("unzip -q %q -d %q", archive_path, extract_to))
    if not (result == 0 or result == true) then
      return nil, "failed to extract zip"
    end
  elseif archive_name:match("%.tar%.gz$") or archive_name:match("%.tgz$") then
    local result = os.execute(string.format("tar -xzf %q -C %q", archive_path, extract_to))
    if not (result == 0 or result == true) then
      return nil, "failed to extract tar.gz"
    end
  elseif archive_name:match("%.gz$") and not archive_name:match("%.tar%.gz$") then
    -- Single file gzip compression
    if not executable_path then
      return nil, "executable_path required for single file gzip"
    end
    local output_path = path_join(extract_to, executable_path)
    mkdir_p(dirname(output_path))
    local result = os.execute(string.format("gunzip -c %q > %q", archive_path, output_path))
    if not (result == 0 or result == true) then
      return nil, "failed to extract gzip"
    end
    return output_path
  else
    return nil, "unsupported archive format: " .. archive_path
  end

  -- For archives, locate the executable
  if executable_path then
    return path_join(extract_to, executable_path)
  else
    return archive_path
  end
end

-- Check if binary is installed (checks if shimlink bin link exists)
local function is_installed(binary_name, config)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    return false
  end

  local bin_link = get_shimlink_bin_link(binary_name)
  return file_exists(bin_link)
end

-- Update config checksum
local function update_config_checksum(binary_name, config, new_checksum)
  config.binaries[binary_name].sha256 = new_checksum

  -- Write to shimlink.lua if it exists, otherwise platform-specific config
  local config_dir = get_config_dir()
  local config_path = path_join(config_dir, "shimlink.lua")
  if not file_exists(config_path) then
    config_path = get_platform_config_path()
  end

  local content = read_file(config_path)

  if not content then
    stderr_write("shimlink: failed to read " .. config_path)
    return
  end

  -- Pattern to match the sha256 field for this binary
  -- Handles both ["binary-name"] and binary_name key formats
  local pattern = '(%[?"?' .. binary_name:gsub("%-", "%%-") .. '"?%]?%s*=%s*%{.-)sha256%s*=%s*"([^"]*)"'
  local replaced = false

  content = content:gsub(pattern, function(before, old_hash)
    replaced = true
    return before .. 'sha256 = "' .. new_checksum .. '"'
  end)

  if not replaced then
    stderr_write("shimlink: warning: could not find sha256 field for " .. binary_name .. " in config")
    return
  end

  write_file(config_path, content)
  stderr_write("shimlink: updated checksum for " .. binary_name .. " to " .. new_checksum)
end

-- Create symlink atomically
local function create_symlink_atomic(target, link_path)
  local temp_link = link_path .. ".tmp." .. os.time()

  -- Create parent directories if needed
  mkdir_p(dirname(link_path))

  -- Remove temp link if it exists
  ffi.C.unlink(temp_link)

  -- Create temporary symlink
  local result = ffi.C.symlink(target, temp_link)
  if result ~= 0 then
    stderr_write("shimlink: failed to create temporary symlink " .. temp_link)
    return false
  end

  -- Atomically replace the target symlink
  local rename_result = os.rename(temp_link, link_path)
  if not rename_result then
    stderr_write("shimlink: failed to rename symlink " .. temp_link .. " to " .. link_path)
    ffi.C.unlink(temp_link)
    return false
  end

  return true
end

-- Create symlink (legacy function for additional symlinks in config)
local function create_symlink(bin_dir, src_path, dest_path, binary_name)
  local source = path_join(bin_dir, src_path)

  if not file_exists(source) then
    stderr_write("shimlink: warning: symlink source does not exist: " .. source)
    return
  end

  local dest = expand_path(dest_path)

  -- Create parent directories if needed
  mkdir_p(dirname(dest))

  -- Remove existing symlink or file
  if file_exists(dest) then
    ffi.C.unlink(dest)
  end

  -- Create the symlink
  local result = ffi.C.symlink(source, dest)
  if result == 0 then
    stderr_write("shimlink: created symlink " .. dest .. " -> " .. source)
  else
    stderr_write("shimlink: warning: failed to create symlink " .. dest)
  end
end

-- Download binary and install to versioned directory
local function download_binary(binary_name, config, force)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    stderr_write("shimlink: no configuration found for " .. binary_name)
    return false
  end

  local url = binary_config.url
  local expected_sha256 = binary_config.sha256
  local path = binary_config.path

  -- Create temporary directory
  local temp_dir = os.tmpname()
  os.remove(temp_dir)
  mkdir_p(temp_dir)

  -- Download
  local download_name = basename(url)
  local download_path = path_join(temp_dir, download_name)

  if not download_file(url, download_path) then
    stderr_write("shimlink: failed to download " .. binary_name)
    rm_rf(temp_dir)
    return false
  end

  -- Calculate checksum of the downloaded artifact (before extraction)
  local actual_sha256 = calculate_sha256(download_path)

  -- Extract or copy binary
  local extract_temp

  if path then
    extract_temp = path_join(temp_dir, "extracted")
    mkdir_p(extract_temp)
    local err
    local extracted_path
    extracted_path, err = extract_archive(download_path, extract_temp, path)
    if not extracted_path then
      stderr_write("shimlink: failed to extract " .. binary_name .. ": " .. err)
      rm_rf(temp_dir)
      return false
    end

    -- Find the actual binary path after stripping components
    local strip_components = binary_config.strip_components or 0
    local binary_dir = extract_temp
    for i = 1, strip_components do
      local handle = io.popen(string.format("ls -1 %q", binary_dir))
      local first_entry = handle:read("*l")
      handle:close()
      if first_entry then
        binary_dir = path_join(binary_dir, first_entry)
      end
    end
    local binary_path = path_join(binary_dir, path)

    -- Make extracted binary executable
    if file_exists(binary_path) then
      ffi.C.chmod(binary_path, tonumber("0755", 8))
    end
  else
    extract_temp = temp_dir
    -- Make downloaded binary executable
    if file_exists(download_path) then
      ffi.C.chmod(download_path, tonumber("0755", 8))
    end
  end

  -- Handle checksum verification and updates
  if force then
    update_config_checksum(binary_name, config, actual_sha256)
    stderr_write("shimlink: force mode - updated checksum for " .. binary_name)
  elseif expected_sha256 then
    if actual_sha256 ~= expected_sha256 then
      stderr_write("shimlink: checksum mismatch for " .. binary_name)
      stderr_write("shimlink:   expected: " .. expected_sha256)
      stderr_write("shimlink:   actual:   " .. actual_sha256)
      rm_rf(temp_dir)
      return false
    end
  end

  -- Create versioned directory using checksum
  local versioned_dir = get_versioned_dir(binary_name, actual_sha256)
  local storage_dir = get_storage_dir(binary_name)
  mkdir_p(storage_dir)

  -- Check if this version already exists
  if is_directory(versioned_dir) then
    stderr_write("shimlink: version " .. actual_sha256:sub(1, 16) .. " already exists")
    rm_rf(temp_dir)
    return true, actual_sha256
  end

  -- Move extracted content to versioned directory
  if path then
    local strip_components = binary_config.strip_components or 0

    if strip_components > 0 then
      -- Strip top-level directories by moving only the inner content
      -- For strip_components=1, we extract to temp, then move the first subdir's contents
      local source_dir = extract_temp
      for i = 1, strip_components do
        -- Find the single directory at this level
        local handle = io.popen(string.format("ls -1 %q", source_dir))
        local first_entry = handle:read("*l")
        handle:close()

        if first_entry then
          source_dir = path_join(source_dir, first_entry)
        else
          stderr_write("shimlink: warning: cannot strip " .. i .. " components, directory empty")
          break
        end
      end
      os.execute(string.format("mv %q %q", source_dir, versioned_dir))
    else
      -- Move the entire extracted directory structure
      os.execute(string.format("mv %q %q", extract_temp, versioned_dir))
    end
  else
    -- For direct binary downloads, create directory and move binary
    mkdir_p(versioned_dir)
    local final_path = path_join(versioned_dir, binary_name)
    os.execute(string.format("mv %q %q", download_path, final_path))
  end

  stderr_write("shimlink: installed " .. binary_name .. " version " .. actual_sha256:sub(1, 16))

  -- Create additional symlinks if configured
  local symlinks = binary_config.symlinks
  if symlinks then
    for src_path, dest_path in pairs(symlinks) do
      create_symlink(versioned_dir, src_path, dest_path, binary_name)
    end
  end

  -- Clean up temp directory
  rm_rf(temp_dir)

  return true, actual_sha256
end

-- Update binary: download and create symlinks
local function update_binary(binary_name, config, force)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    stderr_write("shimlink: no configuration found for " .. binary_name)
    return false
  end

  -- Download and install to versioned directory
  local success, sha256 = download_binary(binary_name, config, force)
  if not success then
    return false
  end

  local versioned_dir = get_versioned_dir(binary_name, sha256)
  local path = binary_config.path
  local binary_path

  if path then
    binary_path = path_join(versioned_dir, path)
  else
    binary_path = path_join(versioned_dir, binary_name)
  end

  if not file_exists(binary_path) then
    stderr_write("shimlink: binary not found at " .. binary_path)
    return false
  end

  -- Create shimlink/bin/ symlink pointing to versioned binary
  local shimlink_bin_link = get_shimlink_bin_link(binary_name)
  local short_sha = sha256:sub(1, 16)

  -- Relative path from shimlink/bin/ to ../_/<binary>/<sha>/<path>
  local relative_to_versioned
  if path then
    relative_to_versioned = path_join("..", "_", binary_name, short_sha, path)
  else
    relative_to_versioned = path_join("..", "_", binary_name, short_sha, binary_name)
  end

  if not create_symlink_atomic(relative_to_versioned, shimlink_bin_link) then
    stderr_write("shimlink: failed to create shimlink bin link for " .. binary_name)
    return false
  end
  stderr_write("shimlink: updated " .. shimlink_bin_link .. " -> " .. relative_to_versioned)

  -- Create alias symlinks if configured
  local aliases = config.aliases or {}
  for alias_name, target_name in pairs(aliases) do
    if target_name == binary_name then
      local alias_link = get_shimlink_bin_link(alias_name)
      if not create_symlink_atomic(binary_name, alias_link) then
        stderr_write("shimlink: warning: failed to create alias " .. alias_name .. " -> " .. binary_name)
      else
        stderr_write("shimlink: created alias " .. alias_link .. " -> " .. binary_name)
      end
    end
  end

  return true
end

-- Resolve alias
local function resolve_alias(name, config)
  local aliases = config.aliases or {}
  return aliases[name] or name
end

-- Get target name
local function get_target_name()
  local invoked_path = arg[0]
  local name = basename(invoked_path)

  if name == "shimlink.lua" or name == "shimlink" then
    return "shimlink"
  end

  return name
end

-- Execute binary (legacy function for on-demand execution)
local function exec_binary(binary_name, args, config)
  local binary_config = config.binaries and config.binaries[binary_name]
  if not binary_config then
    stderr_write("shimlink: no configuration found for " .. binary_name)
    os.exit(1)
  end

  -- Check if binary is installed via shimlink bin link
  local shimlink_bin_link = get_shimlink_bin_link(binary_name)
  if not file_exists(shimlink_bin_link) then
    stderr_write("shimlink: " .. binary_name .. " not installed")
    stderr_write("shimlink: run 'shimlink update " .. binary_name .. "' to install")
    os.exit(1)
  end

  -- Resolve the symlink to get the actual binary path
  local binary_path = shimlink_bin_link

  -- Read the symlink to ensure we're pointing to the right file
  if not file_exists(binary_path) then
    stderr_write("shimlink: binary " .. binary_name .. " not found at " .. binary_path)
    os.exit(1)
  end

  -- Check if there's a custom exec array
  local exec_cmd = binary_config.exec
  local exec_path = binary_path
  local exec_args = {}

  if exec_cmd and type(exec_cmd) == "table" then
    -- Custom exec array: ["/path/to/wrapper", "{binary}", ...]
    -- Build the command by replacing {binary} with binary_path
    exec_path = exec_cmd[1]
    for i = 2, #exec_cmd do
      if exec_cmd[i] == "{binary}" then
        table.insert(exec_args, binary_path)
      else
        table.insert(exec_args, exec_cmd[i])
      end
    end
    -- Append user args
    for _, arg in ipairs(args) do
      table.insert(exec_args, arg)
    end
  else
    -- Normal execution: just the binary and args
    for _, arg in ipairs(args) do
      table.insert(exec_args, arg)
    end
  end

  -- Build argv array for execve
  local argv = ffi.new("char*[?]", #exec_args + 2)
  argv[0] = ffi.cast("char*", exec_path)
  for i, arg_val in ipairs(exec_args) do
    argv[i] = ffi.cast("char*", arg_val)
  end
  argv[#exec_args + 1] = nil

  -- Use the environ global variable directly (works on Linux and macOS)
  -- execve expects char *const envp[], so we just pass environ
  local result = ffi.C.execve(exec_path, argv, ffi.C.environ)

  -- If execve returns, an error occurred
  stderr_write("shimlink: failed to exec " .. exec_path .. ": " .. tostring(result))
  os.exit(1)
end

-- Show help
local function show_help()
  print("shimlink: A symlink-based binary manager")
  print()
  print("Usage:")
  print("  shimlink update <binary>...    # Download and symlink binaries")
  print("  shimlink update -f <binary>... # Force update and update checksum")
  print("  shimlink                       # Show this help")
  print()
  print("Options:")
  print("  -f, --force                    # Skip checksum validation and update config")
  print()
  print("The update command downloads binaries to versioned directories and creates")
  print("atomic symlinks in ~/.local/bin. Binaries are stored in versioned directories")
  print("with a 'current' symlink pointing to the active version.")
  print()
  print("Aliases can be defined in the 'aliases' section of the config to map")
  print("alternative names to actual binary names (e.g., 'nvim-1' -> 'nvim').")
  print()
  print("Configuration: ~/.config/shimlink/shimlink.lua")
  print("Binaries stored: ~/.local/share/shimlink/<binary>/<version>/")
end

-- Main entry point
local function main()
  local target_name = get_target_name()

  if target_name == "shimlink" then
    -- Parse arguments when invoked as shimlink directly
    if #arg == 0 or arg[1] == "-h" or arg[1] == "--help" then
      show_help()
      os.exit(0)
    end

    -- Load configuration
    local ok, config = pcall(load_config)
    if not ok then
      stderr_write("shimlink: failed to load configuration: " .. tostring(config))
      os.exit(1)
    end

    -- Handle update command
    if arg[1] == "update" then
      local force = false
      local binaries = {}

      local i = 2
      while i <= #arg do
        if arg[i] == "-f" or arg[i] == "--force" then
          force = true
        elseif arg[i] == "-h" or arg[i] == "--help" then
          show_help()
          os.exit(0)
        else
          table.insert(binaries, arg[i])
        end
        i = i + 1
      end

      if #binaries == 0 then
        stderr_write("shimlink: update requires at least one binary name")
        os.exit(1)
      end

      local failed = false
      for _, binary in ipairs(binaries) do
        if not update_binary(binary, config, force) then
          stderr_write("shimlink: failed to update " .. binary)
          failed = true
        end
      end

      if failed then
        os.exit(1)
      end
      os.exit(0)
    end

    -- Unknown command
    stderr_write("shimlink: unknown command '" .. arg[1] .. "'")
    stderr_write("shimlink: run 'shimlink' for help")
    os.exit(1)
  end

  -- Legacy mode: invoked through a symlink
  -- Load configuration
  local ok, config = pcall(load_config)
  if not ok then
    stderr_write("shimlink: failed to load configuration: " .. tostring(config))
    os.exit(1)
  end

  -- Resolve alias to actual binary name
  local actual_binary_name = resolve_alias(target_name, config)

  -- Execute the target binary with all arguments
  local args = {}
  for i = 1, #arg do
    table.insert(args, arg[i])
  end
  exec_binary(actual_binary_name, args, config)
end

-- Run main
main()
