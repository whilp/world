#!/usr/bin/env lua

local posix = require('posix')
local dirent = require('posix.dirent')
local stat = require('posix.sys.stat')
local unistd = require('posix.unistd')

local VALID_COMMANDS = {
  ["all-in-one"] = true,
  ["capture-area"] = true,
  ["capture-fullscreen"] = true,
  ["capture-window"] = true,
  ["capture-previous-area"] = true,
  ["self-timer"] = true,
  ["scrolling-capture"] = true,
  ["record-screen"] = true,
  ["capture-text"] = true,
  ["pin"] = true,
  ["open-annotate"] = true,
  ["open-from-clipboard"] = true,
  ["toggle-desktop-icons"] = true,
  ["hide-desktop-icons"] = true,
  ["show-desktop-icons"] = true,
  ["add-quick-access-overlay"] = true,
  ["open-history"] = true,
  ["restore-recently-closed"] = true,
  ["open-settings"] = true,
}

local BOOLEAN_FLAGS = {
  start = true,
  autoscroll = true,
  linebreaks = true,
}

local function url_encode(str)
  str = str:gsub("([^%w%-%.%_%~])", function(c)
    return string.format("%%%02X", string.byte(c))
  end)
  return str
end

local function expand_path(path)
  if path:sub(1, 1) == "~" then
    local home = os.getenv("HOME")
    return home .. path:sub(2)
  end
  return path
end

local function parse_args(args)
  local subcommand = args[1]
  local flags = {}
  local i = 2

  while i <= #args do
    local arg = args[i]
    if arg:match("^%-") then
      local key = arg:match("^%-(.+)$")

      if BOOLEAN_FLAGS[key] then
        flags[key] = "true"
        i = i + 1
      else
        if i + 1 <= #args then
          flags[key] = args[i + 1]
          i = i + 2
        else
          error("flag -" .. key .. " requires a value")
        end
      end
    else
      i = i + 1
    end
  end

  return subcommand, flags
end

local function build_cleanshot_url(subcommand, flags)
  local url = "cleanshot://" .. subcommand
  local params = {}

  for key, value in pairs(flags) do
    if key ~= "path" then
      if key == "filepath" then
        table.insert(params, key .. "=" .. url_encode(value))
      else
        table.insert(params, key .. "=" .. value)
      end
    end
  end

  if #params > 0 then
    url = url .. "?" .. table.concat(params, "&")
  end

  return url
end

local function get_screenshot_directory(flags)
  if flags.path then
    return expand_path(flags.path)
  end
  return expand_path("~/Downloads/screens")
end

local function get_latest_file(dir)
  local entries = dirent.dir(dir)
  if not entries then
    return nil
  end

  local latest_time = 0
  local latest_file = nil

  for _, entry in ipairs(entries) do
    if entry ~= "." and entry ~= ".." then
      local path = dir .. "/" .. entry
      local st = stat.stat(path)
      if st and st.st_mtime > latest_time then
        latest_time = st.st_mtime
        latest_file = path
      end
    end
  end

  return latest_file, latest_time
end

local function wait_for_new_screenshot(dir, baseline_time, timeout)
  local start_time = os.time()

  while os.time() - start_time < timeout do
    local latest_file, latest_time = get_latest_file(dir)
    if latest_file and latest_time > baseline_time then
      return latest_file
    end
    unistd.sleep(1)
  end

  return nil
end

local function should_wait_for_file(subcommand, flags)
  if not flags.action or flags.action ~= "save" then
    return false
  end

  local capture_commands = {
    ["capture-area"] = true,
    ["capture-fullscreen"] = true,
    ["capture-window"] = true,
    ["capture-previous-area"] = true,
    ["self-timer"] = true,
    ["scrolling-capture"] = true,
  }

  return capture_commands[subcommand] == true
end

local function execute_cleanshot_command(url)
  local exit_status = posix.spawn({"open", url})
  if exit_status ~= 0 then
    return nil, "failed to execute cleanshot command"
  end
  return true
end

local function ensure_directory_exists(dir)
  local st = stat.stat(dir)
  if not st then
    local exit_status = posix.spawn({"mkdir", "-p", dir})
    if exit_status ~= 0 then
      return nil, "failed to create directory: " .. dir
    end
  end
  return true
end

local function print_help()
  print([[usage: cleanshot <subcommand> [flags]

subcommands:
  latest                  Print path of most recent screenshot
  all-in-one              Launch all-in-one capture tool
  capture-area            Area capture
  capture-fullscreen      Fullscreen capture
  capture-window          Window capture
  capture-previous-area   Repeat last screenshot
  self-timer              Self-timer capture
  scrolling-capture       Scrolling capture
  record-screen           Screen recording
  capture-text            OCR text recognition
  pin                     Pin image file
  open-annotate           Annotate image
  open-from-clipboard     Annotate clipboard image
  toggle-desktop-icons    Toggle desktop icons visibility
  hide-desktop-icons      Hide desktop icons
  show-desktop-icons      Show desktop icons
  add-quick-access-overlay Add quick access overlay
  open-history            Open capture history
  restore-recently-closed Restore recently deleted
  open-settings           Open settings

flags:
  -x <int>               X coordinate
  -y <int>               Y coordinate
  -width <int>           Width in pixels
  -height <int>          Height in pixels
  -display <int>         Display number (1=main, 2=secondary, etc.)
  -action <string>       Post-capture action (copy, save, annotate, upload, pin)
  -filepath <path>       File path for pin/annotate
  -tab <string>          Settings tab name
  -start                 Auto-start (boolean)
  -autoscroll            Auto-scroll (boolean)
  -linebreaks            Preserve line breaks (boolean)
  -path <dir>            Screenshot directory (default: ~/Downloads/screens)

examples:
  cleanshot capture-area
  cleanshot capture-area -x 100 -y 120 -width 200 -height 150
  cleanshot capture-fullscreen -action save
  cleanshot scrolling-capture -start -autoscroll
  cleanshot record-screen -x 0 -y 0 -width 1920 -height 1080
  cleanshot capture-text -linebreaks
  cleanshot open-settings -tab shortcuts]])
end

local function main(args)
  if #args == 0 or args[1] == "help" or args[1] == "-h" or args[1] == "--help" then
    print_help()
    os.exit(0)
  end

  local subcommand, flags = parse_args(args)

  if subcommand == "latest" then
    local dir = get_screenshot_directory(flags)
    local latest_file = get_latest_file(dir)
    if latest_file then
      print(latest_file)
      os.exit(0)
    else
      error("no screenshots found in " .. dir)
    end
  end

  if not VALID_COMMANDS[subcommand] then
    error("unknown subcommand: " .. subcommand)
  end

  local baseline_time
  local dir

  if should_wait_for_file(subcommand, flags) then
    dir = get_screenshot_directory(flags)
    local ok, err = ensure_directory_exists(dir)
    if not ok then
      error(err)
    end
    _, baseline_time = get_latest_file(dir)
    baseline_time = baseline_time or 0
  end

  local url = build_cleanshot_url(subcommand, flags)
  local ok, err = execute_cleanshot_command(url)
  if not ok then
    error(err)
  end

  if baseline_time then
    local path = wait_for_new_screenshot(dir, baseline_time, 10)
    if path then
      print(path)
    else
      io.stderr:write("warning: screenshot not detected within timeout\n")
      io.stderr:flush()
    end
  end
end

local args = {...}
local ok, err = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(err) .. "\n")
  io.stderr:flush()
  os.exit(1)
end
