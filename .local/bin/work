#!/usr/bin/env lua

package.path = os.getenv("HOME") .. "/.local/lib/lua/?.lua;" .. package.path

local api = require("work.api").init()
local render = require("work.render")

local json_mode = false

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function json_encode(data)
  local json = require("dkjson")
  return json.encode(data, { indent = true })
end

local function json_print(data)
  print(json_encode(data))
end

-- Parse field=value arguments for add/update commands
local function parse_field_args(args, start_index)
  local fields = {}
  for i = start_index, #args do
    local key, value = args[i]:match("^([^=]+)=(.*)$")
    if key then
      fields[key] = value
    else
      error("invalid field argument: " .. args[i])
    end
  end
  return fields
end

local function cmd_add(args)
  if #args < 1 then
    error("usage: work add <title> [field=value...]")
  end

  local title = args[1]
  local opts = {}

  -- Parse field arguments
  if #args >= 2 then
    local fields = parse_field_args(args, 2)
    opts.description = fields.description
    opts.due = fields.due
    opts.priority = fields.priority and tonumber(fields.priority)

    if fields.blocks then
      opts.blocks = {}
      for short_id in fields.blocks:gmatch("[^,]+") do
        short_id = short_id:match("^%s*(.-)%s*$")  -- trim
        table.insert(opts.blocks, short_id)
      end
    end
  end

  local item, err = api.add(title, opts)
  if not item then
    error(err)
  end

  if json_mode then
    json_print(api.clean(item))
  else
    print(item.id)
  end
end

local function cmd_list(args)
  local items, err = api.get_all()
  if not items then
    error(err)
  end

  if json_mode then
    local clean = {}
    for _, item in ipairs(items) do
      table.insert(clean, api.clean(item))
    end
    json_print(clean)
  else
    print(render.list(items))
  end
end

local function cmd_tree(args)
  local root_id = nil
  if #args >= 1 then
    root_id = args[1]
  end

  local tree, err = api.get_tree(root_id)
  if not tree then
    error(err)
  end

  if json_mode then
    -- For JSON, return enriched items array
    local items = tree.roots
    for _, children_list in pairs(tree.children) do
      for _, child in ipairs(children_list) do
        table.insert(items, child)
      end
    end
    local clean = {}
    for _, item in ipairs(items) do
      table.insert(clean, api.clean(item))
    end
    json_print(clean)
  else
    print(render.tree(tree))
  end
end

local function cmd_show(args)
  if #args < 1 then
    error("usage: work show <id>")
  end

  local item, err = api.get(args[1])
  if not item then
    error(err)
  end

  if json_mode then
    json_print(api.clean(item))
  else
    print(render.detail(item))
  end
end

local function cmd_done(args)
  if #args < 1 then
    error("usage: work done <id>")
  end

  local item, err = api.done(args[1])
  if not item then
    error(err)
  end

  if json_mode then
    json_print(api.clean(item))
  else
    print("marked done: " .. item.id)
  end
end

local function cmd_start(args)
  if #args < 1 then
    error("usage: work start <id>")
  end

  local item, err = api.start(args[1])
  if not item then
    error(err)
  end

  if json_mode then
    json_print(api.clean(item))
  else
    print("marked started: " .. item.id)
  end
end

local function cmd_update(args)
  if #args < 2 then
    error("usage: work update <id> <field>=<value>...")
  end

  local id = args[1]
  local updates = parse_field_args(args, 2)

  local item, err = api.update(id, updates)
  if not item then
    error(err)
  end

  if json_mode then
    json_print(api.clean(item))
  else
    print("updated: " .. item.id)
  end
end

local function cmd_rm(args)
  if #args < 1 then
    error("usage: work rm <id>")
  end

  local item, err = api.delete(args[1])
  if not item then
    error(err)
  end

  if json_mode then
    json_print(item)
  else
    print("removed: " .. item.id)
  end
end

-- Parse --limit and --shuffle arguments
local function parse_filter_args(args)
  local limit = nil
  local shuffle = false
  local filtered = {}

  for _, arg in ipairs(args) do
    if arg:match("^%-%-limit=") then
      limit = tonumber(arg:match("^%-%-limit=(%d+)$"))
      if not limit then
        error("--limit must be a number")
      end
    elseif arg == "--shuffle" then
      shuffle = true
    else
      table.insert(filtered, arg)
    end
  end

  return limit, shuffle, filtered
end

local function cmd_blocked(args)
  local limit, shuffle = parse_filter_args(args)

  local items, err = api.get_blocked()
  if not items then
    error(err)
  end

  if shuffle then
    -- Sort by reversed ID (entropy is at the end)
    table.sort(items, function(a, b)
      return a.id > b.id
    end)
  end

  if limit then
    local limited = {}
    for i = 1, math.min(limit, #items) do
      table.insert(limited, items[i])
    end
    items = limited
  end

  if json_mode then
    local clean = {}
    for _, item in ipairs(items) do
      local clean_item = api.clean(item)
      clean_item.unresolved_blocks = item._computed.unresolved_blocks
      table.insert(clean, clean_item)
    end
    json_print(clean)
  else
    print(render.blocked(items))
  end
end

local function cmd_ready(args)
  local limit, shuffle = parse_filter_args(args)

  local items, err = api.get_ready()
  if not items then
    error(err)
  end

  if shuffle then
    -- Sort by reversed ID (entropy is at the end)
    table.sort(items, function(a, b)
      return a.id > b.id
    end)
  end

  if limit then
    local limited = {}
    for i = 1, math.min(limit, #items) do
      table.insert(limited, items[i])
    end
    items = limited
  end

  if json_mode then
    local clean = {}
    for _, item in ipairs(items) do
      table.insert(clean, api.clean(item))
    end
    json_print(clean)
  else
    print(render.ready(items))
  end
end

local function cmd_next(args)
  local limit, shuffle = parse_filter_args(args)

  local items, err = api.get_incomplete()
  if not items then
    error(err)
  end

  if shuffle then
    -- Sort by reversed ID (entropy is at the end)
    table.sort(items, function(a, b)
      return a.id > b.id
    end)
  end

  if limit then
    local limited = {}
    for i = 1, math.min(limit, #items) do
      table.insert(limited, items[i])
    end
    items = limited
  end

  if json_mode then
    local clean = {}
    for _, item in ipairs(items) do
      table.insert(clean, api.clean(item))
    end
    json_print(clean)
  else
    print(render.ready(items))
  end
end

local function cmd_log(args)
  if #args < 2 then
    error("usage: work log id=<id> <message>")
  end

  local short_id = args[1]:match("^id=(.+)$")
  if not short_id then
    error("first argument must be id=<id>")
  end

  local message_parts = {}
  for i = 2, #args do
    table.insert(message_parts, args[i])
  end
  local message = table.concat(message_parts, " ")

  local timestamp, err = api.log(short_id, message)
  if not timestamp then
    error(err)
  end

  local full_id, resolve_err = api.resolve_id(short_id)
  if not full_id then
    error(resolve_err)
  end

  if json_mode then
    json_print({
      id = full_id,
      timestamp = timestamp,
      message = message,
    })
  else
    print("logged to " .. full_id .. " at " .. timestamp)
  end
end

local function main(args)
  -- Parse global flags
  local filtered_args = {}
  for _, arg in ipairs(args) do
    if arg == "--json" then
      json_mode = true
    else
      table.insert(filtered_args, arg)
    end
  end
  args = filtered_args

  if #args == 0 or args[1] == "help" then
    print("usage: work [--json] <command> [args...]")
    print("")
    print("flags:")
    print("  --json                             output in json format")
    print("")
    print("commands:")
    print("  add <title> [field=value...]       add new work item")
    print("  list                               list all work items")
    print("  tree [id]                          show work items as dependency tree")
    print("  show <id>                          show work item details")
    print("  done <id>                          mark work item as done")
    print("  start <id>                         mark work item as started")
    print("  update <id> <field>=<value>...     update work item fields")
    print("  rm <id>                            remove work item")
    print("  blocked                            list blocked items")
    print("  ready [--limit=N] [--shuffle]      show next ready (unblocked) items")
    print("  next [--limit=N] [--shuffle]       show next N incomplete items by schedule")
    print("  log id=<id> <message>              append log entry with timestamp")
    os.exit(0)
  end

  local command = args[1]
  local cmd_args = { unpack(args, 2) }

  local commands = {
    add = cmd_add,
    list = cmd_list,
    tree = cmd_tree,
    show = cmd_show,
    done = cmd_done,
    start = cmd_start,
    update = cmd_update,
    rm = cmd_rm,
    blocked = cmd_blocked,
    ready = cmd_ready,
    next = cmd_next,
    log = cmd_log,
  }

  local cmd_fn = commands[command]
  if not cmd_fn then
    error("unknown command: " .. command)
  end

  cmd_fn(cmd_args)
end

local args = { ... }
local ok, err = pcall(main, args)
if not ok then
  stderr_write("work: error: " .. tostring(err))
  os.exit(1)
end
