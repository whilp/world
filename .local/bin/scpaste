#!/usr/bin/env python3
"""
scpaste - Transfer clipboard content to remote hosts via SSH control sockets.

Finds SSH control sockets associated with the current Alacritty window,
gets clipboard content in multiple formats, and transfers to remote hosts.
"""

import os
import sys
import subprocess
import datetime
import tempfile
from pathlib import Path
from typing import List, Dict, Optional, Set


def log(message: str):
    """Simple logging to /tmp/scpaste.log"""
    with open("/tmp/scpaste.log", "a") as f:
        timestamp = datetime.datetime.now().isoformat()
        f.write(f"[{timestamp}] {message}\n")


def get_process_table():
    """Get the complete process table once"""
    try:
        result = subprocess.run(
            ["ps", "-eo", "pid,ppid,comm"], capture_output=True, text=True, timeout=10
        )
    except (subprocess.SubprocessError, subprocess.TimeoutExpired):
        return {}

    if result.returncode != 0:
        return {}

    process_table = {}
    for line in result.stdout.strip().split("\n")[1:]:  # Skip header
        parts = line.strip().split(None, 2)
        if len(parts) < 3:
            continue
        pid, ppid, comm = parts[0], parts[1], parts[2]
        process_table[pid] = {"pid": pid, "ppid": ppid, "comm": comm}

    return process_table


def trace_process_ancestry(pid, process_table):
    """Trace process ancestry using pre-loaded process table"""
    ancestry = []
    current_pid = str(pid)

    while current_pid != "1" and current_pid in process_table:
        process_info = process_table[current_pid]
        ancestry.append(process_info)
        current_pid = process_info["ppid"]

    return ancestry


def get_alacritty_pid_from_env():
    """Get current Alacritty PID from environment variable"""
    alacritty_socket = os.environ.get("ALACRITTY_SOCKET")
    if not alacritty_socket:
        return None

    success, output, _ = run_lsof_command(
        ["-F", "pc", alacritty_socket], timeout=5, log_errors=False
    )
    if not success:
        return None

    records = parse_lsof_fields(output)
    for record in records:
        if record.get("command") == "alacritty":
            return record.get("pid")

    return None


def find_alacritty_in_ancestry(ancestry):
    """Check if Alacritty is in the process ancestry"""
    for process in ancestry:
        if "alacritty" in process["comm"].lower():
            return process["pid"]
    return None


def run_lsof_command(
    args: List[str], timeout: int = 10, log_errors: bool = True
) -> tuple:
    """Run lsof command with standardized error handling."""
    try:
        result = subprocess.run(
            ["lsof"] + args, capture_output=True, text=True, timeout=timeout
        )
    except (subprocess.SubprocessError, subprocess.TimeoutExpired) as e:
        if log_errors:
            log(f"lsof command failed: {e}")
        return False, "", str(e)

    if result.returncode != 0:
        if log_errors:
            log(f"lsof failed with return code {result.returncode}")
        return False, "", result.stderr

    return True, result.stdout, ""


def parse_lsof_fields(output: str) -> List[Dict[str, str]]:
    """Parse lsof -F output into structured records."""
    records = []
    current_record = {}

    for line in output.strip().split("\n"):
        if not line:
            continue

        field_type = line[0]
        field_value = line[1:]

        if field_type == "p":
            # New process record starts
            if current_record:
                records.append(current_record)
            current_record = {"pid": field_value}
        elif field_type in ["c", "n", "t"]:
            current_record[{"c": "command", "n": "name", "t": "type"}[field_type]] = (
                field_value
            )

    # Don't forget the last record
    if current_record:
        records.append(current_record)

    return records


def process_ssh_socket(current_process, field_value, process_table, socket_groups):
    """Process an SSH socket entry and add it to socket groups"""
    # Check if this is an SSH process using a socket
    if not (
        current_process.get("command") == "ssh"
        and current_process.get("type") == "unix"
        and field_value.startswith("/")
        and not field_value.startswith("->")
    ):
        return

    # Clean socket path (remove temporary suffixes)
    clean_socket_path = field_value
    if ".sock." in field_value:
        clean_socket_path = field_value.split(".sock.")[0] + ".sock"

    # Trace ancestry
    ancestry = trace_process_ancestry(current_process["pid"], process_table)
    alacritty_pid = find_alacritty_in_ancestry(ancestry)

    process_info = {
        "pid": current_process["pid"],
        "command": current_process["command"],
        "original_path": field_value,
        "type": current_process["type"],
        "ancestry": ancestry,
        "alacritty_pid": alacritty_pid,
        "is_master": "[mux]" in field_value,
    }

    # Group by socket path
    if clean_socket_path not in socket_groups:
        socket_groups[clean_socket_path] = {
            "socket_path": clean_socket_path,
            "processes": [],
            "alacritty_pid": None,
        }

    socket_groups[clean_socket_path]["processes"].append(process_info)

    # If any process has Alacritty ancestry, mark the whole group
    if alacritty_pid and not socket_groups[clean_socket_path]["alacritty_pid"]:
        socket_groups[clean_socket_path]["alacritty_pid"] = alacritty_pid


def find_ssh_socket_groups():
    """Find SSH processes grouped by socket path"""
    # Get process table once for efficient ancestry lookups
    process_table = get_process_table()

    success, output, _ = run_lsof_command(
        ["-U", "-F", "pcnt"], timeout=10, log_errors=True
    )
    if not success:
        return {}

    socket_groups = {}
    records = parse_lsof_fields(output)

    for record in records:
        # Process each record that has a name field (socket path)
        if "name" in record:
            process_ssh_socket(record, record["name"], process_table, socket_groups)

    # Now find SSH clients that use ControlPath to link to these sockets
    try:
        ps_result = subprocess.run(
            ["ps", "-eo", "pid,command"], capture_output=True, text=True, timeout=10
        )
    except (subprocess.SubprocessError, subprocess.TimeoutExpired):
        return socket_groups  # Return what we have so far

    if ps_result.returncode != 0:
        return socket_groups  # Return what we have so far

    for line in ps_result.stdout.strip().split("\n")[1:]:  # Skip header
        parts = line.strip().split(None, 1)
        if len(parts) < 2:
            continue

        pid, command = parts[0], parts[1]

        # Look for SSH clients with ControlPath
        if not (
            ("/usr/bin/ssh" in command or command.startswith("ssh "))
            and "-o ControlPath=" in command
            and "[mux]" not in command
        ):
            continue

        # Extract ControlPath
        try:
            control_path = command.split("-o ControlPath=")[1].split()[0]
        except (IndexError, ValueError):
            continue

        # Check if this ControlPath matches any of our socket groups
        for socket_path, group in socket_groups.items():
            if control_path != socket_path:
                continue

            # Get ancestry for this SSH client
            ancestry = trace_process_ancestry(pid, process_table)
            alacritty_pid = find_alacritty_in_ancestry(ancestry)

            # If client has Alacritty ancestry, inherit it to the socket group
            if alacritty_pid and not group["alacritty_pid"]:
                group["alacritty_pid"] = alacritty_pid
                group["alacritty_source"] = f"client-{pid}"

            # Add client info to the group
            client_info = {
                "pid": pid,
                "command": "ssh-client",
                "original_path": f"client-using-{control_path}",
                "type": "client",
                "ancestry": ancestry,
                "alacritty_pid": alacritty_pid,
                "is_master": False,
            }
            group["processes"].append(client_info)
            break

    return socket_groups


def find_relevant_sockets(alacritty_pid: str) -> Dict[str, Dict]:
    """Find SSH sockets relevant to this Alacritty instance."""
    socket_groups = find_ssh_socket_groups()

    # Filter for groups that belong to the current Alacritty window
    relevant_sockets = {}
    for socket_path, group in socket_groups.items():
        if group.get("alacritty_pid") == alacritty_pid:
            # Test socket connectivity
            try:
                result = subprocess.run(
                    ["ssh", "-S", socket_path, "-O", "check", "dummy"],
                    capture_output=True,
                    text=True,
                    timeout=5,
                )
                if result.returncode == 0:
                    relevant_sockets[socket_path] = group
                    log(f"Socket {socket_path} is connectable")
                else:
                    log(
                        f"Socket {socket_path} failed connectivity test: {result.stderr}"
                    )
            except (subprocess.SubprocessError, subprocess.TimeoutExpired) as e:
                log(f"Socket {socket_path} connectivity test failed: {e}")
                continue

    log(
        f"Found {len(relevant_sockets)} relevant sockets for Alacritty PID {alacritty_pid}"
    )
    return relevant_sockets


def parse_clipboard_data(raw_data: str, format_class: str) -> Optional[str]:
    """Parse raw clipboard data based on its format class."""
    if not raw_data:
        return None

    # Text formats - return as-is
    if format_class in ["TEXT", "utf8"]:
        return raw_data

    # Binary formats - extract hex data
    if format_class in ["PNGf", "HTML", "RTF "]:
        # Look for hex data pattern: ¬´data TYPE...hex...¬ª
        if "¬´data" in raw_data and "¬ª" in raw_data:
            hex_data = raw_data.split("¬´data", 1)[1].split("¬ª", 1)[0]
            hex_data = hex_data.replace(format_class, "").strip()

            if not hex_data:
                return None

            # For binary formats like PNG, return hex as-is
            if format_class == "PNGf":
                return hex_data

            # For text-based formats, decode hex to text
            try:
                return bytes.fromhex(hex_data).decode("utf-8", errors="ignore")
            except Exception:
                return None

    # Unknown format - return raw data
    return raw_data


def get_clipboard_content() -> Dict[str, str]:
    """Get clipboard content in all available formats."""
    formats = {}

    # First, get clipboard info to see what formats are available
    try:
        info_result = subprocess.run(
            ["osascript", "-e", 'tell application "System Events" to clipboard info'],
            capture_output=True,
            text=True,
        )
        if info_result.returncode != 0:
            log(f"Failed to get clipboard info: {info_result.stderr}")
            return {}
    except Exception as e:
        log(f"Error getting clipboard info: {e}")
        return {}

    clipboard_info = info_result.stdout.strip()
    log(f"Clipboard info: {clipboard_info}")

    # Try to get PNG data
    if "PNGf" in clipboard_info:
        try:
            png_result = subprocess.run(
                [
                    "osascript",
                    "-e",
                    'tell application "System Events" to get the clipboard as ¬´class PNGf¬ª',
                ],
                capture_output=True,
                text=True,
            )
            if png_result.returncode == 0 and png_result.stdout.strip():
                png_data = png_result.stdout.strip()
                # Parse PNG data: ¬´data PNGf...hex...
                if png_data.startswith("¬´data PNGf") and png_data.endswith("¬ª"):
                    hex_data = png_data[10:-1]  # Remove ¬´data PNGf and ¬ª
                    formats["png"] = hex_data
                    log(f"Retrieved PNG data: {len(hex_data)} hex chars")
        except Exception as e:
            log(f"Error getting PNG data: {e}")

    # Try to get text data
    try:
        text_result = subprocess.run(["pbpaste"], capture_output=True, text=True)
        if text_result.returncode == 0 and text_result.stdout.strip():
            content = text_result.stdout.strip()
            formats["txt"] = content
            log(f"Retrieved text content: {len(content)} chars")
    except Exception as e:
        log(f"Error getting text content: {e}")

    if not formats:
        log("No clipboard content found")

    return formats


def transfer_to_hosts(
    sockets: Dict[str, Dict], clipboard_content: Dict[str, str]
) -> List[str]:
    """Transfer clipboard content to remote hosts via SSH sockets."""
    if not clipboard_content:
        print("‚ö†Ô∏è  No clipboard content found")
        return []

    if not sockets:
        print("‚ö†Ô∏è  No SSH sockets found")
        return []

    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    all_created_files = []

    for socket_path, group in sockets.items():
        print(f"üì° Transferring via {socket_path}...")
        process_count = len(group.get("processes", []))
        log(f"Transferring via {socket_path} ({process_count} processes)")

        # Test connection and ensure ~/pastes directory exists
        try:
            subprocess.run(
                ["ssh", "-S", socket_path, "-O", "check", "dummy"],
                check=True,
                capture_output=True,
            )
            # If check succeeds, create the directory (SSH will use the control master)
            subprocess.run(
                ["ssh", "-S", socket_path, "dummy", "mkdir -p ~/pastes"],
                check=True,
                capture_output=True,
            )
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Error accessing socket {socket_path}: {e}")
            continue

        created_files = []
        for ext, content in clipboard_content.items():
            if not content.strip():
                continue

            filename = f"~/pastes/{timestamp}.{ext}"

            try:
                # Create temporary file
                if ext == "png":
                    mode, file_content = "wb", bytes.fromhex(content)
                else:
                    mode, file_content = "w", content

                with tempfile.NamedTemporaryFile(
                    mode=mode, suffix=f".{ext}", delete=False
                ) as temp_file:
                    temp_file.write(file_content)
                    temp_file_path = temp_file.name

                try:
                    # Transfer via scp (SSH will determine host from control master)
                    scp_cmd = [
                        "scp",
                        "-o",
                        f"ControlPath={socket_path}",
                        temp_file_path,
                        f"dummy:{filename}",
                    ]
                    result = subprocess.run(scp_cmd, capture_output=True, text=True)

                    if result.returncode == 0:
                        created_files.append(filename)
                    else:
                        log(f"SCP error for {filename}: {result.stderr}")
                finally:
                    os.unlink(temp_file_path)

            except Exception as e:
                log(f"Error transferring {ext} via {socket_path}: {e}")

        if created_files:
            print(f"‚úÖ Created {len(created_files)} files via {socket_path}:")
            for file in created_files:
                print(f"   üìÑ {file}")
            all_created_files.extend(created_files)
        else:
            print(f"‚ùå No files created via {socket_path}")

    return all_created_files


def main(environ: Dict[str, str], argv: List[str]) -> int:
    """Main function."""
    log("=== scpaste started ===")

    alacritty_pid = get_alacritty_pid_from_env()
    if not alacritty_pid:
        print("‚ùå Error: Not running in Alacritty or unable to detect PID")
        return 1

    log(f"Using Alacritty PID: {alacritty_pid}")

    # Find relevant SSH sockets
    sockets = find_relevant_sockets(alacritty_pid)
    if not sockets:
        print("‚ùå No SSH sockets found for this Alacritty window")
        return 1

    print(f"üîå Found {len(sockets)} SSH socket groups:")
    for socket_path, group in sockets.items():
        process_count = len(group.get("processes", []))
        print(f"   ‚Ä¢ {socket_path} ({process_count} processes)")

    # Get clipboard content
    clipboard_content = get_clipboard_content()
    if not clipboard_content:
        print("‚ùå No clipboard content found")
        return 1

    print(f"üìã Found clipboard formats: {', '.join(clipboard_content.keys())}")

    # Transfer to remote hosts
    created_files = transfer_to_hosts(sockets, clipboard_content)

    if created_files:
        print(
            f"\nüéâ Successfully created {len(created_files)} files across {len(sockets)} hosts"
        )
    else:
        print("\n‚ùå No files were created")

    log("=== scpaste completed ===")
    return 0


if __name__ == "__main__":
    sys.exit(main(os.environ, sys.argv))
