#!/usr/bin/env lua

package.path = os.getenv("HOME") .. "/.local/lib/lua/?.lua;" .. package.path

local daemonize = require("daemonize")
local unistd = require("posix.unistd")
local stat = require("posix.sys.stat")

local function stderr_write(msg)
  io.stderr:write(msg .. "\n")
  io.stderr:flush()
end

local function parse_args(args)
  local opts = {
    append = false,
    chdir = nil,
    stderr_file = nil,
    stdout_file = nil,
    pidfile = nil,
    user = nil,
    lockfile = nil,
    verbose = false,
    env = {},
  }

  local i = 1
  while i <= #args do
    local arg = args[i]

    if arg == "-a" then
      opts.append = true
      i = i + 1
    elseif arg == "-c" then
      if i + 1 > #args then
        error("option -c requires an argument")
      end
      opts.chdir = args[i + 1]
      i = i + 2
    elseif arg == "-e" then
      if i + 1 > #args then
        error("option -e requires an argument")
      end
      opts.stderr_file = args[i + 1]
      i = i + 2
    elseif arg == "-E" then
      if i + 1 > #args then
        error("option -E requires an argument")
      end
      local env_arg = args[i + 1]
      local name, value = env_arg:match("^([^=]+)=(.*)$")
      if not name then
        error("invalid environment variable format: " .. env_arg)
      end
      opts.env[name] = value
      i = i + 2
    elseif arg == "-o" then
      if i + 1 > #args then
        error("option -o requires an argument")
      end
      opts.stdout_file = args[i + 1]
      i = i + 2
    elseif arg == "-p" then
      if i + 1 > #args then
        error("option -p requires an argument")
      end
      opts.pidfile = args[i + 1]
      i = i + 2
    elseif arg == "-u" then
      if i + 1 > #args then
        error("option -u requires an argument")
      end
      opts.user = args[i + 1]
      i = i + 2
    elseif arg == "-l" then
      if i + 1 > #args then
        error("option -l requires an argument")
      end
      opts.lockfile = args[i + 1]
      i = i + 2
    elseif arg == "-v" then
      opts.verbose = true
      i = i + 1
    elseif arg == "-h" or arg == "--help" then
      return nil, nil
    elseif arg == "--" then
      local cmd = {}
      for j = i + 1, #args do
        table.insert(cmd, args[j])
      end
      return opts, cmd
    elseif not arg:match("^%-") then
      local cmd = {}
      for j = i, #args do
        table.insert(cmd, args[j])
      end
      return opts, cmd
    else
      error("unknown option: " .. arg)
    end
  end

  return opts, {}
end

local function verbose(opts, msg)
  if opts.verbose then
    stderr_write(msg)
  end
end

local function main(args)
  if #args == 0 then
    print([[usage: daemonize [options] <command> [args...]

options:
  -a              append to output files (default: overwrite)
  -c <dir>        set working directory
  -e <stderr>     redirect stderr to file
  -E var=value    set environment variable (can repeat)
  -o <stdout>     redirect stdout to file
  -p <pidfile>    write pid to file
  -u <user>       run as user (requires root)
  -l <lockfile>   single-instance enforcement via lock file
  -v              verbose output]])
    os.exit(0)
  end

  local opts, cmd = parse_args(args)

  if not opts then
    print([[usage: daemonize [options] <command> [args...]

options:
  -a              append to output files (default: overwrite)
  -c <dir>        set working directory
  -e <stderr>     redirect stderr to file
  -E var=value    set environment variable (can repeat)
  -o <stdout>     redirect stdout to file
  -p <pidfile>    write pid to file
  -u <user>       run as user (requires root)
  -l <lockfile>   single-instance enforcement via lock file
  -v              verbose output]])
    os.exit(0)
  end

  if #cmd == 0 then
    error("no command specified")
  end

  verbose(opts, "daemonize: command: " .. cmd[1])

  local st = stat.stat(cmd[1])
  if not st then
    local path_cmd = io.popen("which " .. cmd[1] .. " 2>/dev/null")
    local path = path_cmd:read("*l")
    path_cmd:close()
    if not path or path == "" then
      error("command not found: " .. cmd[1])
    end
  end

  local lock_fd = nil
  if opts.lockfile then
    verbose(opts, "daemonize: acquiring lock: " .. opts.lockfile)
    local fd, err = daemonize.acquire_lock(opts.lockfile)
    if not fd then
      error(err)
    end
    lock_fd = fd
  end

  if opts.user then
    verbose(opts, "daemonize: switching to user: " .. opts.user)
    local ok, err = daemonize.switch_user(opts.user)
    if not ok then
      error(err)
    end
  end

  verbose(opts, "daemonize: forking...")
  local ok, err = daemonize.daemon({
    nochdir = (opts.chdir ~= nil),
    noclose = (opts.stdout_file ~= nil or opts.stderr_file ~= nil),
  })
  if not ok then
    error(err)
  end

  if lock_fd then
    unistd.ftruncate(lock_fd, 0)
    unistd.lseek(lock_fd, 0, 0)
    local pid_str = tostring(unistd.getpid()) .. "\n"
    unistd.write(lock_fd, pid_str, #pid_str)
  end

  if opts.pidfile then
    daemonize.write_pidfile(opts.pidfile)
  end

  if opts.chdir then
    unistd.chdir(opts.chdir)
  end

  if opts.stdout_file or opts.stderr_file then
    daemonize.redirect_output(opts.stdout_file, opts.stderr_file, opts.append)
  end

  for name, value in pairs(opts.env) do
    daemonize.setenv(name, value)
  end

  unistd.execp(cmd[1], cmd)
  os._exit(127)
end

local args = {...}
local ok, err = pcall(main, args)
if not ok then
  stderr_write("daemonize: " .. tostring(err))
  os.exit(1)
end
