#!/usr/bin/env luajit

local posix = require('posix')
local unistd = require('posix.unistd')
local wait = require('posix.sys.wait')
local signal = require('posix.signal')

local function is_filtered_error(line)
  local patterns = {
    "CFMessagePort: dropping corrupt reply Mach message",
    "error communicating with Hammerspoon: message port was invalidated",
    "error unregistering CLI instance with Hammerspoon: message port invalid",
    "transport errors are normal if Hammerspoon is reloading"
  }

  for _, pattern in ipairs(patterns) do
    if line:find(pattern, 1, true) then
      return true
    end
  end
  return false
end

local function filter_output(output)
  local filtered = {}
  for line in output:gmatch("[^\r\n]+") do
    if not is_filtered_error(line) then
      table.insert(filtered, line)
    end
  end
  return filtered
end

local function main()
  local out_read, out_write = unistd.pipe()
  local err_read, err_write = unistd.pipe()

  if not out_read or not err_read then
    io.stderr:write("error: failed to create pipes\n")
    io.stderr:flush()
    os.exit(1)
  end

  local pid = posix.fork()
  if not pid then
    io.stderr:write("error: failed to fork\n")
    io.stderr:flush()
    os.exit(1)
  end

  if pid == 0 then
    unistd.close(out_read)
    unistd.close(err_read)
    unistd.dup2(out_write, unistd.STDOUT_FILENO)
    unistd.dup2(err_write, unistd.STDERR_FILENO)
    unistd.close(out_write)
    unistd.close(err_write)
    posix.exec("hs", {"-c", "hs.reload()"})
    os.exit(1)
  end

  unistd.close(out_write)
  unistd.close(err_write)

  signal.signal(signal.SIGALRM, function()
    posix.kill(pid, signal.SIGTERM)
  end)
  unistd.alarm(2)

  local stdout = unistd.read(out_read, 65536) or ""
  local stderr = unistd.read(err_read, 65536) or ""

  unistd.close(out_read)
  unistd.close(err_read)

  local _, reason, exit_code = wait.wait(pid)
  unistd.alarm(0)

  if stdout and stdout ~= "" then
    io.write(stdout)
  end

  local filtered_lines = filter_output(stderr)
  if #filtered_lines > 0 then
    for _, line in ipairs(filtered_lines) do
      io.stderr:write(line)
      io.stderr:write("\n")
    end
    io.stderr:flush()
  end

  os.exit(0)
end

local ok, err = pcall(main)
if not ok then
  io.stderr:write("error: " .. tostring(err) .. "\n")
  io.stderr:flush()
  os.exit(1)
end
