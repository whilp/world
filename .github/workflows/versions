#!/usr/bin/env luajit

local version = require("version")

local function versions_path()
  return os.getenv("HOME") .. "/.github/workflows/versions.lua"
end

local function load_versions()
  return version.load(versions_path())
end

local function parse_params(args)
  local params = {}
  for _, arg in ipairs(args) do
    local key, value = arg:match("^([^=]+)=(.+)$")
    if key and value then
      params[key] = value
    end
  end
  return params
end

local function apply_updates(versions, params)
  for key, value in pairs(params) do
    versions[key] = value
  end
  return versions
end

local function cmd_show(args)
  local params = parse_params(args)

  local versions = load_versions()
  versions = apply_updates(versions, params)

  print(version.render(versions))
end

local function cmd_write(args)
  local params = parse_params(args)

  local versions = load_versions()
  versions = apply_updates(versions, params)

  local rendered = version.render(versions)

  local path = versions_path()
  local f = io.open(path, "w")
  if not f then
    error("failed to open file for writing: " .. path)
  end
  f:write(rendered)
  f:close()

  print("updated " .. path)
  for key, value in pairs(params) do
    print("  " .. key .. ": " .. value)
  end
end

local function cmd_help()
  print([[versions - manage workflow dependency versions

usage:
  versions show [key=value...]
    show versions with optional updates applied (does not persist)

  versions write [key=value...]
    update versions and persist to disk

examples:
  versions show
  versions show luajit=abc123...
  versions write luajit=25a61a182166fec06f1a1a025eb8fabbb6cf483e
  versions write luasocket=3.1.0-1 luasec=1.3.2-1
]])
end

local function main(args)
  if #args == 0 or args[1] == "help" or args[1] == "--help" then
    cmd_help()
    os.exit(0)
  end

  local command = args[1]
  local cmd_args = {unpack(args, 2)}

  if command == "show" then
    cmd_show(cmd_args)
  elseif command == "write" then
    cmd_write(cmd_args)
  else
    error("unknown command: " .. command)
  end
end

local args = {...}
local ok, err = pcall(main, args)
if not ok then
  io.stderr:write("error: " .. tostring(err) .. "\n")
  os.exit(1)
end
